{"version":3,"file":"index2.js","sources":["src/prophet/types.ts","src/prophet/array/reverse.ts","src/prophet/array/join.ts","src/prophet/array/Array.ts","src/prophet/string/split.ts","src/prophet/string/substr.ts","src/prophet/execution-context/ExecutionContext.ts","src/prophet/Object.ts","src/prophet/parseECMACompliant.ts","src/prophet/Function/Function.ts","src/prophet/string/String.ts","src/prophet/boolean/ESBoolean.ts","src/prophet/operators.ts","src/prophet/ASTResolvers.ts","src/prophet/evaluate.ts","src/prophet/window/prompt.ts","src/prophet/math/round.ts","src/prophet/math/Math.ts","src/prophet/eval/eval.ts","src/prophet/number/Number.ts","src/prophet/Object/ObjectConstructor.ts","src/prophet/execution-context/ESInitialGlobal.ts","src/prophet/error/SyntaxError.ts","src/prophet/node-builtin-modules/vm.ts","src/prophet/node-builtin-modules/NodeBuiltInModules.ts","src/prophet/require/require.ts","src/prophet/execution-context/nodeInitialExecutionContext.ts"],"sourcesContent":["import { isObject, keys } from \"lodash\";\nimport { TESString } from \"./string/String\";\nimport { TExecutionContext } from \"./execution-context/ExecutionContext\";\nimport { TESObject } from \"./Object\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\n\nexport const NotANumber = {};\nexport const Number = {};\nexport const TODOTYPE = {};\n\nexport type TESUndefined = Type<\"undefined\">;\n\nexport type TESNull = Type<\"null\">;\n\nexport const ESNull: TESNull = {\n  type: \"null\"\n};\n\nexport function isESNull(arg: any): arg is TESNull {\n  return arg.type === \"null\";\n}\n\nexport const Undefined: TESUndefined = {\n  type: \"undefined\"\n};\n\nexport function isUndefined(arg: any): arg is TESUndefined {\n  return arg.type === \"undefined\";\n}\n\nexport function isESString(arg: any): arg is TESString {\n  return arg.type === \"string\";\n}\n\nexport function isArray(arg: any) {\n  return arg.type === \"array\";\n}\n\nexport type TESNumber = Type<\"number\"> & WithProperties & WithValue<number>;\n\nexport function ESNumber(value?: number): TESNumber {\n  return {\n    type: \"number\",\n    id: ValueIdentifier(),\n    properties: {},\n    value\n  };\n}\n\nexport function isESNumber(arg: any): arg is TESNumber {\n  return arg.type === \"number\";\n}\n\nexport type GreaterThanEquals = {\n  gte: number;\n};\n\nexport type FunctionImplementation = (\n  self: Any,\n  args: Array<Any>,\n  execContext: TExecutionContext\n) => IterableIterator<[EvaluationResult, TExecutionContext]>;\n\nexport type Function = {\n  implementation: FunctionImplementation;\n};\n\nexport function isFunction(arg: any): arg is Function {\n  return (\n    isObject(arg) && keys(arg).length === 1 && keys(arg)[0] === \"implementation\"\n  );\n}\n\nexport type FunctionBinding = WithProperties & {\n  self?: Any;\n  function: Function;\n};\n\nexport type WithProperties = {\n  properties: {\n    [name: string]: Any;\n  };\n};\n\nexport function ValueIdentifier() {\n  return {} as object;\n}\n\nexport type Type<T extends string> = {\n  type: T;\n};\n\nexport type TValueIdentifier = ReturnType<typeof ValueIdentifier>;\n\nexport type WithValue<T> = {\n  id?: TValueIdentifier;\n  value?: T;\n};\n\nexport type TReturnValue = {\n  type: \"ReturnValue\";\n  value: Any;\n};\n\nexport function ReturnValue(value: Any) {\n  return {\n    type: \"ReturnValue\",\n    value\n  };\n}\n\nexport function isReturnValue(arg: any): arg is TReturnValue {\n  return arg.type === \"ReturnValue\";\n}\n\nexport type TThrownValue = {\n  type: \"ThrownValue\";\n  value: Any;\n};\n\nexport function ThrownValue(value: Any) {\n  return {\n    type: \"ThrownValue\",\n    value\n  };\n}\n\nexport function isThrownValue(arg: any): arg is TThrownValue {\n  return arg.type === \"ThrownValue\";\n}\n\nexport type TESBoolean = Type<\"boolean\"> &\n  WithProperties &\n  WithValue<boolean> & {};\n\nexport function isESBoolean(arg: Any): arg is TESBoolean {\n  return unsafeCast<Type<string>>(arg).type === \"boolean\";\n}\n\nexport type Any =\n  | Type<string>\n  | typeof NotANumber\n  | TESString\n  | typeof Number\n  | TESUndefined\n  | GreaterThanEquals\n  | Function\n  | TESObject\n  | FunctionBinding\n  | TESBoolean\n  | TThrownValue;\n\nexport type ExpressionEvaluationResult = TThrownValue | Any;\nexport type ControlFlowResult = TThrownValue | TReturnValue;\nexport type EvaluationResult = Any | ControlFlowResult;\n","import { isArray, Any } from \"../types\";\nimport { TArray, Array } from \"./Array\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\n\nexport function* reverse(\n  self: TArray<any>,\n  _args: Array<Any>,\n  execContext: TExecutionContext\n) {\n  return [\n    Array(\n      (self.value as Array<TArray<any>>).reverse().map(part => {\n        if (isArray(part) && part.value) {\n          return Array(part.value.reverse(), part.concrete);\n        }\n        return part;\n      }),\n      self.concrete\n    ),\n    execContext\n  ];\n}\n","import { Any, isArray } from \"../types\";\nimport { isUndefined } from \"lodash\";\nimport { TArray } from \"./Array\";\nimport { TESString, ESString } from \"../string/String\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\n\nexport function* join(\n  self: TArray<any>,\n  args: [TESString, ...Array<Any>],\n  execContext: TExecutionContext\n) {\n  const reduceArray = (arg: TArray<any>): TESString => {\n    if (!arg.value) {\n      return ESString();\n    }\n    return (arg.value as Array<TArray<any>>).reduce((result, part) => {\n      let stringOfCurrentPart;\n      if (isArray(part)) {\n        stringOfCurrentPart = reduceArray(part);\n      } else {\n        stringOfCurrentPart = part;\n      }\n\n      let stringToConcatTo = result;\n      if (\n        !isUndefined(stringToConcatTo.value) &&\n        !isUndefined(stringOfCurrentPart.value)\n      ) {\n        stringToConcatTo.value =\n          (stringToConcatTo.value as string) +\n          args[0].value +\n          stringOfCurrentPart.value;\n        return result;\n      } else {\n        return ESString([result, stringOfCurrentPart as TESString]);\n      }\n    }, ESString(\"\"));\n  };\n\n  return [reduceArray(self), execContext];\n}\n","import { reverse } from \"./reverse\";\nimport { join } from \"./join\";\nimport { Number, TESNumber, GreaterThanEquals } from \"../types\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\n\nexport type TArray<T> = {\n  value?: Array<T> | Array<TArray<T>>;\n  concrete?: boolean;\n};\n\nexport function Array<T>(\n  value?: Array<T> | Array<TArray<T>>,\n  concrete?: boolean\n) {\n  return {\n    type: \"array\",\n    properties: {\n      reverse: {\n        implementation: reverse\n      },\n      join: {\n        implementation: join\n      },\n      length: calculateLength(value, concrete)\n    },\n    value,\n    concrete\n  };\n}\n\nfunction calculateLength(\n  value?: string | Array<TArray<any>>,\n  concrete?: boolean\n): typeof Number | TESNumber | GreaterThanEquals {\n  if (!value) {\n    return Number;\n  }\n  if (concrete) {\n    return { number: value.length };\n  }\n  return unsafeCast<Array<TArray<any>>>(value).reduce(\n    (result, part) => {\n      if (!result) {\n        return calculateLength(part.value, part.concrete);\n      } else {\n        const currentPartLength = calculateLength(part.value, part.concrete);\n        if (currentPartLength === Number) {\n          return {\n            gte: unsafeCast<TESNumber>(result).value\n          };\n        }\n        return {\n          gte: unsafeCast<TESNumber>(currentPartLength).value\n        };\n      }\n    },\n    (undefined as any) as typeof Number | TESNumber | GreaterThanEquals\n  );\n}\n","import { Any } from \"../types\";\nimport { TESString, ESString } from \"./String\";\nimport { Array } from \"../array/Array\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\n\nexport function* split(\n  self: TESString,\n  args: [TESString, ...Array<Any>],\n  execContext: TExecutionContext\n) {\n  return [\n    Array(\n      (self.value as Array<TESString>).map(part => {\n        if (part.value) {\n          return Array(\n            (part.value as string)\n              .split(args[0].value as string)\n              .map(string => ESString(string)),\n            true\n          );\n        }\n        return Array();\n      })\n    ),\n    execContext\n  ];\n}\n","import { Any, TESNumber } from \"../types\";\nimport { first } from \"lodash\";\nimport { TESString, ESString } from \"./String\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\n\nexport function* substr(\n  self: TESString,\n  args: [TESNumber, TESNumber, ...Array<Any>],\n  execContext: TExecutionContext\n) {\n  return [\n    ESString(\n      ((first(self.value as Array<TESString>) as TESString)\n        .value as string).substr(\n        unsafeCast<number>(args[0].value),\n        unsafeCast<number>(args[1].value)\n      )\n    ),\n    execContext\n  ];\n}\n","import { Any } from \"../types\";\nimport { TESObject } from \"../Object\";\n\nexport type TExecutionContext = {\n  value: {\n    thisValue: Any;\n    scope: {\n      [identifier: string]: Any;\n    };\n    global: TESObject;\n    stderr: string;\n  };\n};\n\nexport function ExecutionContext(value: any) {\n  return {\n    type: \"ExecutionContext\",\n    value\n  };\n}\n\nexport function setCurrentThisValue(\n  execContext: TExecutionContext,\n  val: Any\n): TExecutionContext {\n  return ExecutionContext({ ...execContext.value, thisValue: val });\n}\n\nexport function setVariableInScope(\n  execContext: TExecutionContext,\n  name: string,\n  val: Any\n) {\n  return ExecutionContext({\n    ...execContext.value,\n    scope: { ...execContext.value.scope, [name]: val }\n  });\n}\n","import {\n  WithProperties,\n  Any,\n  WithValue,\n  Type,\n  ValueIdentifier,\n  FunctionBinding\n} from \"./types\";\nimport {\n  TExecutionContext,\n  setCurrentThisValue\n} from \"./execution-context/ExecutionContext\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { tuple } from \"@deaven/tuple\";\n\nexport type TESObject = Type<\"object\"> &\n  WithProperties &\n  WithValue<{ [key: string]: Any }> & {\n    type: \"object\";\n  };\n\nexport function ESObject(value?: { [key: string]: Any }): TESObject {\n  return {\n    type: \"object\",\n    id: ValueIdentifier(),\n    properties: value || {},\n    value\n  };\n}\n\nexport function isESObject(arg: any): arg is TESObject {\n  return arg.type === \"object\";\n}\n\nexport function* createNewObjectFromConstructor(\n  calleeType: FunctionBinding,\n  argsTypes: Any[],\n  execContext: TExecutionContext\n) {\n  const thisValue = ESObject({});\n  const currExecContext = setCurrentThisValue(execContext, thisValue);\n\n  const [, afterCallExecContext] = yield* calleeType.function.implementation(\n    thisValue,\n    argsTypes,\n    currExecContext\n  );\n\n  return tuple(\n    ESObject({\n      ...unsafeCast<TESObject>(calleeType.properties.prototype).properties,\n      ...unsafeCast<TESObject>(afterCallExecContext.value.thisValue).value\n    }),\n    afterCallExecContext\n  );\n}\n","import { parseScript, ESTree } from \"cherow\";\n\nexport function parseECMACompliant(code: string): ESTree.Program {\n  return parseScript(code, { loc: true });\n}\n","import { TESString } from \"../string/String\";\nimport {\n  Any,\n  Undefined,\n  FunctionImplementation,\n  FunctionBinding,\n  isReturnValue,\n  EvaluationResult\n} from \"../types\";\nimport {\n  TExecutionContext,\n  setVariableInScope\n} from \"../execution-context/ExecutionContext\";\nimport { evaluate } from \"../evaluate\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { ESObject } from \"../Object\";\nimport { tuple } from \"@deaven/tuple\";\nimport { parseECMACompliant } from \"../parseECMACompliant\";\nimport { ESTree } from \"cherow\";\n\nexport function ESFunction(implementation: FunctionImplementation) {\n  return {\n    type: \"function\",\n    properties: {\n      prototype: ESObject()\n    },\n    function: {\n      implementation\n    }\n  };\n}\n\nexport function isESFunction(arg: any): arg is FunctionBinding {\n  return arg.type === \"function\";\n}\n\nexport const FunctionConstructor = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext: TExecutionContext\n) {\n  const blockStatement = ((parseECMACompliant(\n    `() => {${unsafeCast<TESString>(args[0]).value as string}}`\n  ).body[0] as ESTree.ExpressionStatement)\n    .expression as ESTree.ArrowFunctionExpression)\n    .body as ESTree.BlockStatement;\n  return [createFunction(blockStatement.body, []), execContext] as [\n    FunctionBinding,\n    TExecutionContext\n  ];\n});\n\nexport function createFunction(\n  statements: ESTree.Statement[],\n  params: Array<ESTree.Pattern>\n) {\n  return {\n    type: \"function\",\n    properties: {\n      prototype: ESObject()\n    },\n    function: {\n      implementation: function*(\n        _self: Any,\n        args: Array<Any>,\n        execContext: TExecutionContext\n      ) {\n        const atferParametersInScopeExecContext = params.reduce(\n          (prevContext, parameter, index) =>\n            setVariableInScope(\n              prevContext,\n              unsafeCast<ESTree.Identifier>(parameter).name,\n              args[index]\n            ),\n          execContext\n        );\n\n        let currentEvaluationResult = tuple(\n          Undefined,\n          atferParametersInScopeExecContext\n        ) as [EvaluationResult, TExecutionContext];\n\n        for (const statement of statements) {\n          currentEvaluationResult = evaluate(\n            statement,\n            currentEvaluationResult[1]\n          );\n          if (isReturnValue(currentEvaluationResult[0])) {\n            return tuple(\n              currentEvaluationResult[0].value,\n              currentEvaluationResult[1]\n            );\n          } else {\n            yield currentEvaluationResult;\n          }\n        }\n\n        return tuple(Undefined, currentEvaluationResult[1]);\n      }\n    }\n  };\n}\n","import { split } from \"./split\";\nimport { substr } from \"./substr\";\nimport {\n  Number,\n  WithProperties,\n  Any,\n  GreaterThanEquals,\n  TESNumber,\n  WithValue,\n  ValueIdentifier,\n  Type\n} from \"../types\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { ESFunction } from \"../Function/Function\";\n\nexport interface TESString\n  extends Type<\"string\">,\n    WithProperties,\n    WithValue<string | Array<TESString>> {}\n\nexport function ESString(value?: string | Array<TESString>): TESString {\n  return {\n    type: \"string\",\n    id: ValueIdentifier(),\n    properties: {\n      toString: {\n        function: {\n          implementation: function*(\n            self: TESString,\n            _args: Array<Any>,\n            execContext: TExecutionContext\n          ) {\n            return [self, execContext];\n          }\n        }\n      },\n      split: {\n        implementation: split\n      },\n      substr: {\n        implementation: substr\n      },\n      length: calculateLength(value)\n    },\n    value\n  };\n}\n\nexport const StringConstructor = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext\n) {\n  return [args[0], execContext] as [Any, TExecutionContext];\n});\n\nfunction calculateLength(\n  value?: string | Array<TESString>\n): typeof Number | TESNumber | GreaterThanEquals {\n  if (!value) {\n    return Number;\n  }\n  if (typeof value === \"string\") {\n    return { number: value.length };\n  }\n  return value.reduce(\n    (result, part) => {\n      if (!result) {\n        return calculateLength(part.value);\n      } else {\n        return {\n          gte: (result as TESNumber).value\n        };\n      }\n    },\n    (undefined as any) as typeof Number | Any | GreaterThanEquals\n  );\n}\n","import {\n  TESBoolean,\n  Any,\n  ValueIdentifier,\n  isESBoolean,\n  isESNumber,\n  isESNull,\n  isUndefined,\n  isESString,\n  Undefined\n} from \"../types\";\nimport { isESObject } from \"../Object\";\nimport { ESFunction, isESFunction } from \"../Function/Function\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { unimplemented } from \"../../unimplemented\";\n\nexport function ESBoolean(value?: boolean): TESBoolean {\n  return {\n    type: \"boolean\",\n    id: ValueIdentifier(),\n    properties: {},\n    value\n  };\n}\n\nexport function coerceToBoolean(val: Any): TESBoolean {\n  if (isESBoolean(val)) {\n    return val;\n  }\n\n  if (isESNumber(val)) {\n    return typeof val.value === \"number\"\n      ? val.value === 0\n        ? ESBoolean(false)\n        : ESBoolean(true)\n      : ESBoolean();\n  }\n\n  if (isESNull(val) || isUndefined(val)) {\n    return ESBoolean(false);\n  }\n\n  if (isESString(val)) {\n    return typeof val.value === \"string\"\n      ? val.value === \"\"\n        ? ESBoolean(false)\n        : ESBoolean(true)\n      : unimplemented();\n  }\n\n  if (isESObject(val)) {\n    return ESBoolean(true);\n  }\n\n  if (isESFunction(val)) {\n    return ESBoolean(true);\n  }\n\n  return unimplemented();\n}\n\nexport const ESBooleanConstructor = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext\n) {\n  return [coerceToBoolean(args[0] || Undefined), execContext] as [\n    Any,\n    TExecutionContext\n  ];\n});\n","import {\n  Any,\n  GreaterThanEquals,\n  TESNumber,\n  isESString,\n  WithValue,\n  ExpressionEvaluationResult,\n  isUndefined,\n  isESNumber,\n  ESNumber,\n  isESBoolean,\n  Type,\n  Undefined\n} from \"./types\";\nimport { ESString, TESString } from \"./string/String\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { ESBoolean, coerceToBoolean } from \"./boolean/ESBoolean\";\nimport { TExecutionContext } from \"./execution-context/ExecutionContext\";\nimport { _ } from \"@deaven/bottomdash\";\nimport { evaluate } from \"./evaluate\";\nimport { tuple } from \"@deaven/tuple\";\nimport { ESTree } from \"cherow\";\nimport { unimplemented } from \"../unimplemented\";\n\nexport type BinaryOperatorResolver = (left: Any, right: Any) => Any;\nexport type UnaryOperatorResolver = (\n  arg: Any,\n  execContext: TExecutionContext\n) => [Any, TExecutionContext];\nexport type LogicalOperatorResolver = (\n  left: ESTree.Expression,\n  right: ESTree.Expression,\n  execContext: TExecutionContext\n) => IterableIterator<[ExpressionEvaluationResult, TExecutionContext]>;\n\nexport function plus(left: Any, right: Any) {\n  if (isESString(left) && typeof left.value === \"string\") {\n    if (isESString(right)) {\n      return ESString(left.value + right.value);\n    }\n    return ESString(left.value + \"true\");\n  }\n  return ESString([unsafeCast<TESString>(left), unsafeCast<TESString>(right)]);\n}\n\nexport function minus(left: Any, right: Any) {\n  if (\n    isESNumber(left) &&\n    typeof left.value === \"number\" &&\n    isESNumber(right) &&\n    typeof right.value === \"number\"\n  ) {\n    return ESNumber(left.value - right.value);\n  }\n\n  return unimplemented();\n}\n\nexport function greaterThan(left: Any, right: Any) {\n  return (\n    unsafeCast<GreaterThanEquals>(left).gte >\n    unsafeCast<number>(unsafeCast<TESNumber>(right).value)\n  );\n}\n\nexport function exactEquality(left: Any, right: Any) {\n  if (isUndefined(left) && isUndefined(right)) {\n    return ESBoolean(true);\n  }\n\n  if (\n    isESNumber(left) &&\n    typeof left.value === \"number\" &&\n    isESNumber(right) &&\n    typeof right.value === \"number\"\n  ) {\n    return ESBoolean(left.value === right.value);\n  }\n\n  return ESBoolean(\n    unsafeCast<WithValue<any>>(left).id === unsafeCast<WithValue<any>>(right).id\n  );\n}\n\nexport function notExactEquality(left: Any, right: Any) {\n  if (isUndefined(left)) {\n    if (isUndefined(right)) {\n      return ESBoolean(false);\n    } else {\n      return ESBoolean(true);\n    }\n  }\n  if (\n    isESNumber(left) &&\n    typeof left.value === \"number\" &&\n    isESNumber(right) &&\n    typeof right.value === \"number\"\n  ) {\n    return ESBoolean(left.value !== right.value);\n  }\n\n  if (\n    isESString(left) &&\n    typeof left.value === \"string\" &&\n    isESString(right) &&\n    typeof right.value === \"string\"\n  ) {\n    return ESBoolean(left.value !== right.value);\n  }\n\n  if (\n    isESBoolean(left) &&\n    typeof left.value === \"boolean\" &&\n    isESBoolean(right) &&\n    typeof right.value === \"boolean\"\n  ) {\n    return ESBoolean(left.value !== right.value);\n  }\n\n  return ESBoolean(\n    unsafeCast<WithValue<any>>(left).id !== unsafeCast<WithValue<any>>(right).id\n  );\n}\n\nexport const logicalAnd = _<LogicalOperatorResolver>(function*(\n  left,\n  right,\n  execContext\n) {\n  const [leftType, afterLeftExecContext] = yield evaluate(left, execContext);\n  const leftTypeAsBoolean = coerceToBoolean(leftType);\n  if (leftTypeAsBoolean.value === true) {\n    const [rightType, afterRightExecContext] = yield evaluate(\n      right,\n      afterLeftExecContext\n    );\n    const rightTypeAsBoolean = coerceToBoolean(rightType);\n    if (rightTypeAsBoolean.value === true) {\n      return [rightType, afterRightExecContext];\n    }\n\n    return unimplemented();\n  } else if (leftTypeAsBoolean.value === false) {\n    return [leftType, afterLeftExecContext];\n  }\n\n  return unimplemented();\n});\n\nexport const logicalOr = _<LogicalOperatorResolver>(function*(\n  left,\n  _right,\n  execContext\n) {\n  const [leftType, afterLeftExecContext] = yield evaluate(left, execContext);\n  const leftTypeAsBoolean = coerceToBoolean(leftType);\n  if (leftTypeAsBoolean.value === true) {\n    return [leftType, afterLeftExecContext];\n  }\n\n  return unimplemented();\n});\n\nexport const equal = _<BinaryOperatorResolver>((left, right) => {\n  if (\n    isESBoolean(left) &&\n    typeof left.value === \"boolean\" &&\n    isESBoolean(right) &&\n    typeof right.value === \"boolean\"\n  ) {\n    return ESBoolean(left.value == right.value);\n  }\n\n  return unimplemented();\n});\n\nexport const notEqual = _<BinaryOperatorResolver>((left, right) => {\n  return ESBoolean(\n    unsafeCast<TESNumber>(left).value != unsafeCast<TESNumber>(right).value\n  );\n});\n\nexport const not = _<UnaryOperatorResolver>((arg, execContext) => {\n  const argAsBoolean = coerceToBoolean(arg);\n  if (typeof argAsBoolean.value === \"boolean\") {\n    return tuple(ESBoolean(!argAsBoolean.value), execContext);\n  }\n\n  return unimplemented();\n});\n\nexport const typeOf = _<UnaryOperatorResolver>((arg, execContext) => {\n  return tuple(ESString(unsafeCast<Type<string>>(arg).type), execContext);\n});\n\nexport const unaryMinus = _<UnaryOperatorResolver>((arg, execContext) => {\n  return tuple(\n    ESNumber(-unsafeCast<number>(unsafeCast<TESNumber>(arg).value)),\n    execContext\n  );\n});\n\nexport const unaryVoid = _<UnaryOperatorResolver>((_, execContext) => {\n  return tuple(Undefined, execContext);\n});\n\nexport const BinaryOperatorResolvers = new Map<string, BinaryOperatorResolver>([\n  [\">\", greaterThan],\n  [\"+\", plus],\n  [\"-\", minus],\n  [\"===\", exactEquality],\n  [\"!==\", notExactEquality],\n  [\"!=\", notEqual],\n  [\"==\", equal]\n]);\n\nexport const LogicalOperatorResolvers = new Map<\n  string,\n  LogicalOperatorResolver\n>([[\"&&\", logicalAnd], [\"||\", logicalOr]]);\n\nexport const UnaryOperatorResolvers = new Map<string, UnaryOperatorResolver>([\n  [\"!\", not],\n  [\"-\", unaryMinus],\n  [\"typeof\", typeOf],\n  [\"void\", unaryVoid]\n]);\n","/// <reference types=\"node\" />\n\nimport { ESString, TESString } from \"./string/String\";\nimport {\n  WithProperties,\n  isFunction,\n  Any,\n  Undefined,\n  FunctionBinding,\n  isThrownValue,\n  ReturnValue,\n  EvaluationResult,\n  ControlFlowResult,\n  ThrownValue,\n  TESNumber,\n  ESNumber,\n  ESNull\n} from \"./types\";\nimport { evaluate, evaluateThrowableIterator } from \"./evaluate\";\nimport {\n  BinaryOperatorResolvers,\n  LogicalOperatorResolvers,\n  UnaryOperatorResolvers\n} from \"./operators\";\nimport {\n  TExecutionContext,\n  setCurrentThisValue,\n  setVariableInScope,\n  ExecutionContext\n} from \"./execution-context/ExecutionContext\";\nimport { createFunction } from \"./Function/Function\";\nimport { isNull } from \"util\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { ESObject, createNewObjectFromConstructor } from \"./Object\";\nimport { coerceToBoolean, ESBoolean } from \"./boolean/ESBoolean\";\nimport { tuple } from \"@deaven/tuple\";\nimport assert from \"assert\";\nimport { ESTree } from \"cherow\";\nimport { unimplemented } from \"../unimplemented\";\n\nexport type ASTResolver<TAST extends ESTree.Node, T extends Any> = (\n  ast: TAST,\n  prevContext: TExecutionContext\n) => Iterator<[T | ControlFlowResult, TExecutionContext]>;\n\nexport const noExecutionContextResolver = <\n  TAST extends ESTree.Node,\n  T extends Any\n>(\n  fn: (ast: TAST, execContext: TExecutionContext) => T\n) =>\n  function*(ast: TAST, execContext: TExecutionContext) {\n    return tuple(fn(ast, execContext), execContext);\n  };\n\nexport const statementResolver = <TStatement extends ESTree.Statement>(\n  fn: (\n    ast: TStatement,\n    execContext: TExecutionContext\n  ) => IterableIterator<[EvaluationResult, TExecutionContext]>\n) =>\n  function*(ast: TStatement, execContext: TExecutionContext) {\n    const resultIter = fn(ast, execContext);\n\n    return evaluateThrowableIterator(resultIter);\n  };\n\nexport const IdentifierResolver: ASTResolver<\n  ESTree.Identifier,\n  Any\n> = noExecutionContextResolver((ast, execContext) => {\n  const resolvedFromScope = execContext.value.scope[ast.name];\n  return (\n    resolvedFromScope ||\n    execContext.value.global.properties[ast.name] ||\n    Undefined\n  );\n});\n\nexport const LiteralResolver: ASTResolver<\n  ESTree.Literal,\n  Any\n> = noExecutionContextResolver(ast => {\n  if (typeof ast.value === \"string\") {\n    return ESString(ast.value);\n  } else if (typeof ast.value === \"number\") {\n    return ESNumber(ast.value);\n  } else if (typeof ast.value === \"boolean\") {\n    return ESBoolean(ast.value);\n  } else if (ast.value === null) {\n    return ESNull;\n  }\n\n  return unimplemented();\n});\n\nexport const MemberExpressionResolver: ASTResolver<\n  ESTree.MemberExpression,\n  Any\n> = function*(ast, execContext) {\n  const [objectType, newExecContext] = yield evaluate(ast.object, execContext);\n  const propertyType = unsafeCast<WithProperties>(objectType).properties[\n    unsafeCast<ESTree.Identifier>(ast.property).name\n  ];\n  if (isFunction(propertyType)) {\n    return tuple(\n      {\n        self: objectType,\n        function: propertyType\n      },\n      newExecContext\n    );\n  } else {\n    return tuple(propertyType, newExecContext);\n  }\n};\n\nexport const CallExpressionResolver: ASTResolver<\n  ESTree.CallExpression,\n  Any\n> = function*(ast, execContext) {\n  let [calleeType, newExecContext] = yield evaluate(ast.callee, execContext);\n\n  let currExecContext = newExecContext;\n  let argsTypes: Any[] = [];\n\n  for (const argAST of ast.arguments) {\n    const [argType, newExecContext] = yield evaluate(argAST, currExecContext);\n    argsTypes = [...argsTypes, argType];\n    currExecContext = newExecContext;\n  }\n\n  currExecContext = setCurrentThisValue(\n    currExecContext,\n    unsafeCast<FunctionBinding>(calleeType).self || currExecContext.value.global\n  );\n\n  return yield* unsafeCast<FunctionBinding>(calleeType).function.implementation(\n    unsafeCast<FunctionBinding>(calleeType).self ||\n      currExecContext.value.global,\n    argsTypes,\n    currExecContext\n  );\n};\n\nexport const BinaryExpressionResolver: ASTResolver<\n  ESTree.BinaryExpression,\n  any | TESString\n> = function*(ast, execContext) {\n  const [leftType, leftExecContext] = yield evaluate(ast.left, execContext);\n  const [rightType, rightExecContext] = yield evaluate(\n    ast.right,\n    leftExecContext\n  );\n  const binaryOperatorResolver = BinaryOperatorResolvers.get(ast.operator);\n  assert(\n    binaryOperatorResolver,\n    `Binary operator resolver for ${ast.operator} hasn't been implemented yet`\n  );\n  return tuple(binaryOperatorResolver!(leftType, rightType), rightExecContext);\n};\n\n// export const FileResolver: ASTResolver<File, Any> = (ast, execContext) => {\n//   return ProgramResolver(ast.program, execContext);\n// };\n\nexport const ProgramResolver: ASTResolver<ESTree.Program, Any> = function*(\n  ast,\n  execContext\n) {\n  const programFunction = createFunction(\n    unsafeCast<ESTree.Statement[]>(ast.body),\n    []\n  );\n  const programIter = programFunction.function.implementation(\n    execContext.value.global,\n    [],\n    execContext\n  );\n\n  const currentEvaluationResult = evaluateThrowableIterator(programIter);\n\n  if (isThrownValue(currentEvaluationResult[0])) {\n    const [resultAsString, resultExecContext] = yield* unsafeCast<\n      FunctionBinding\n    >(\n      unsafeCast<WithProperties>(currentEvaluationResult[0].value).properties[\n        \"toString\"\n      ]\n    ).function.implementation(\n      currentEvaluationResult[0].value,\n      [],\n      currentEvaluationResult[1]\n    );\n    return tuple(\n      Undefined,\n      ExecutionContext({\n        ...resultExecContext.value,\n        stderr: unsafeCast<TESString>(resultAsString).value\n      })\n    );\n  }\n\n  return tuple(Undefined, currentEvaluationResult[1]);\n};\n\nexport const BlockStatementResolver = statementResolver<ESTree.BlockStatement>(\n  function*(ast, execContext) {\n    let currExecContext = execContext;\n    for (const statement of ast.body) {\n      [, currExecContext] = yield evaluate(statement, currExecContext);\n    }\n\n    return tuple(Undefined, currExecContext);\n  }\n);\n\nexport const AssignmentExpressionResolver: ASTResolver<\n  ESTree.AssignmentExpression,\n  Any\n> = function*(ast, execContext) {\n  if (ast.left.type === \"MemberExpression\") {\n    const [objectType, afterLeftExecContext] = yield evaluate(\n      ast.left.object,\n      execContext\n    );\n    const [rightType, afterRightExecContext] = yield evaluate(\n      ast.right,\n      afterLeftExecContext\n    );\n    unsafeCast<WithProperties>(objectType).properties[\n      unsafeCast<ESTree.Identifier>(ast.left.property).name\n    ] = rightType;\n    return tuple(rightType, afterRightExecContext);\n  } else {\n    const [rightType, afterRightExecContext] = yield evaluate(\n      ast.right,\n      execContext\n    );\n    return tuple(\n      rightType,\n      setVariableInScope(\n        afterRightExecContext,\n        unsafeCast<ESTree.Identifier>(ast.left).name,\n        rightType\n      )\n    );\n  }\n};\n\nexport const ReturnStatementResolver = statementResolver<\n  ESTree.ReturnStatement\n>(function*(statement, execContext) {\n  if (isNull(statement.argument)) {\n    return tuple(ReturnValue(Undefined), execContext);\n  }\n  const [argType, afterArgExecContext] = yield evaluate(\n    statement.argument,\n    execContext\n  );\n  return tuple(ReturnValue(argType), afterArgExecContext);\n});\n\nexport const ThisExpressionResolver: ASTResolver<\n  ESTree.ThisExpression,\n  Any\n> = function*(_ast, execContext) {\n  return tuple(execContext.value.thisValue, execContext);\n};\n\nexport const ObjectExpressionResolver: ASTResolver<\n  ESTree.ObjectExpression,\n  Any\n> = function*(ast, execContext) {\n  let obj = {};\n  let currExecContext = execContext;\n  for (const property of ast.properties) {\n    let propValueType;\n    if (property.type === \"Property\") {\n      if (property.shorthand) {\n        [propValueType, currExecContext] = yield evaluate(\n          property.key,\n          currExecContext\n        );\n      } else {\n        [propValueType, currExecContext] = yield evaluate(\n          unsafeCast<ESTree.Node>(property.value),\n          currExecContext\n        );\n      }\n    }\n\n    obj = {\n      ...obj,\n      [unsafeCast<ESTree.Identifier>(unsafeCast<ESTree.Property>(property).key)\n        .name]: propValueType\n    };\n  }\n\n  return tuple(ESObject(obj), currExecContext);\n};\n\nexport const FunctionExpressionResolver: ASTResolver<\n  ESTree.FunctionExpression,\n  FunctionBinding\n> = function*(ast, execContext) {\n  const functionType = createFunction(ast.body.body, ast.params);\n\n  return tuple(\n    functionType,\n    ast.id\n      ? setVariableInScope(\n          execContext,\n          unsafeCast<ESTree.Identifier>(ast.id).name,\n          functionType\n        )\n      : execContext\n  );\n};\n\nexport const ExpressionStatementResolver = statementResolver<\n  ESTree.ExpressionStatement\n>(function*(statement, execContext) {\n  const result = yield evaluate(statement.expression, execContext);\n  return tuple(Undefined, result[1]);\n});\n\nexport const VariableDeclarationResolver = statementResolver<\n  ESTree.VariableDeclaration\n>(function*(statement, execContext) {\n  let currExecContext = execContext;\n  for (const declaration of statement.declarations) {\n    if (declaration.init) {\n      const initResult = yield evaluate(declaration.init, currExecContext);\n      currExecContext = setVariableInScope(\n        initResult[1],\n        unsafeCast<ESTree.Identifier>(declaration.id).name,\n        initResult[0]\n      );\n    } else {\n      currExecContext = setVariableInScope(\n        currExecContext,\n        unsafeCast<ESTree.Identifier>(declaration.id).name,\n        Undefined\n      );\n    }\n  }\n  return tuple(Undefined, currExecContext);\n});\n\nexport const FunctionDeclarationResolver = statementResolver<\n  ESTree.FunctionDeclaration\n>(function*(statement, execContext) {\n  return tuple(\n    Undefined,\n    setVariableInScope(\n      execContext,\n      unsafeCast<ESTree.Identifier>(statement.id).name,\n      createFunction(statement.body.body, statement.params)\n    )\n  );\n});\n\nexport const IfStatementResolver = statementResolver<ESTree.IfStatement>(\n  function*(statement, prevContext) {\n    const [testType, afterTestExecContext] = yield evaluate(\n      statement.test,\n      prevContext\n    );\n    const testTypeAsBoolean = coerceToBoolean(testType);\n\n    if (testTypeAsBoolean.value === true) {\n      const [, consequentExecContext] = yield evaluate(\n        statement.consequent,\n        afterTestExecContext\n      );\n      return tuple(Undefined, consequentExecContext);\n    } else if (testTypeAsBoolean.value === false) {\n      if (statement.alternate) {\n        const [, consequentExecContext] = yield evaluate(\n          statement.alternate,\n          afterTestExecContext\n        );\n        return tuple(Undefined, consequentExecContext);\n      }\n\n      return tuple(Undefined, afterTestExecContext);\n    }\n\n    return unimplemented();\n  }\n);\n\nexport const EmptyStatementResolver = statementResolver<ESTree.EmptyStatement>(\n  function*(_, execContext) {\n    return tuple(Undefined, execContext);\n  }\n);\n\nexport const NewExpressionResolver: ASTResolver<\n  ESTree.NewExpression,\n  Any\n> = function*(expression, execContext) {\n  let [calleeType, newExecContext] = yield evaluate(\n    expression.callee,\n    execContext\n  );\n\n  let currExecContext = newExecContext;\n  let argsTypes: Any[] = [];\n\n  for (const argAST of expression.arguments) {\n    const [argType, newExecContext] = yield evaluate(argAST, execContext);\n    argsTypes = [...argsTypes, argType];\n    currExecContext = newExecContext;\n  }\n\n  return yield* createNewObjectFromConstructor(\n    unsafeCast<FunctionBinding>(calleeType),\n    argsTypes,\n    currExecContext\n  );\n};\n\nexport const LogicalExpressionResolver: ASTResolver<\n  ESTree.LogicalExpression,\n  Any\n> = function*(expression, execContext) {\n  const logicalOperatorResolver = LogicalOperatorResolvers.get(\n    expression.operator\n  );\n  assert(\n    logicalOperatorResolver,\n    `Logical operator for ${expression.operator} has not been implemented yet`\n  );\n  return yield* logicalOperatorResolver!(\n    expression.left,\n    expression.right,\n    execContext\n  );\n};\n\nexport const TryStatementResolver = statementResolver<ESTree.TryStatement>(\n  function*(statement, execContext) {\n    const tryBlockEvaluationResult = evaluate(statement.block, execContext);\n    if (isThrownValue(tryBlockEvaluationResult[0])) {\n      const preCatchHandlerExecContext = setVariableInScope(\n        tryBlockEvaluationResult[1],\n        unsafeCast<ESTree.Identifier>(\n          unsafeCast<ESTree.CatchClause>(statement.handler).param\n        ).name,\n        tryBlockEvaluationResult[0].value\n      );\n      return evaluate(\n        unsafeCast<ESTree.CatchClause>(statement.handler).body,\n        preCatchHandlerExecContext\n      );\n    }\n\n    return tryBlockEvaluationResult;\n  }\n);\n\nexport const ThrowStatementResolver = statementResolver<ESTree.ThrowStatement>(\n  function*(statement, execContext) {\n    const [argType, afterArgExecContext] = yield evaluate(\n      statement.argument,\n      execContext\n    );\n    return tuple(ThrownValue(argType), afterArgExecContext);\n  }\n);\n\nexport const DoWhileStatementResolver = statementResolver<\n  ESTree.DoWhileStatement\n>(function*(_statement, execContext) {\n  return tuple(Undefined, execContext);\n});\n\nexport const UpdateExpressionResolver: ASTResolver<\n  ESTree.UpdateExpression,\n  TESNumber\n> = function*(expression, execContext) {\n  if (expression.argument.type === \"Identifier\") {\n    const [argType, afterArgExecContext] = yield evaluate(\n      expression.argument,\n      execContext\n    );\n\n    let argTypeAfterUpdate: TESNumber;\n    if (expression.operator === \"++\") {\n      argTypeAfterUpdate = ESNumber(\n        unsafeCast<number>(unsafeCast<TESNumber>(argType).value) + 1\n      );\n    } else {\n      return unimplemented();\n    }\n\n    const afterUpdateExecContext = setVariableInScope(\n      afterArgExecContext,\n      expression.argument.name,\n      argTypeAfterUpdate\n    );\n\n    return tuple(argTypeAfterUpdate, afterUpdateExecContext);\n  }\n\n  return unimplemented();\n};\n\nexport const UnaryExpressionResolver: ASTResolver<\n  ESTree.UnaryExpression,\n  Any\n> = function*(expression, execContext) {\n  const [argType, afterArgExecContext] = yield evaluate(\n    expression.argument,\n    execContext\n  );\n  const unaryOperatorResolver = UnaryOperatorResolvers.get(expression.operator);\n  assert(\n    unaryOperatorResolver,\n    `Unary operator resolver for ${\n      expression.operator\n    } hasn't been implemented yet`\n  );\n  return unaryOperatorResolver!(argType, afterArgExecContext);\n};\n\nexport const ASTResolvers = new Map<string, ASTResolver<any, any>>([\n  [\"Literal\", LiteralResolver],\n  [\"Identifier\", IdentifierResolver],\n  [\"MemberExpression\", MemberExpressionResolver],\n  [\"CallExpression\", CallExpressionResolver],\n  [\"BinaryExpression\", BinaryExpressionResolver],\n  [\"Program\", ProgramResolver],\n  [\"AssignmentExpression\", AssignmentExpressionResolver],\n  [\"ReturnStatement\", ReturnStatementResolver],\n  [\"ThisExpression\", ThisExpressionResolver],\n  [\"ObjectExpression\", ObjectExpressionResolver],\n  [\"FunctionExpression\", FunctionExpressionResolver],\n  [\"ExpressionStatement\", ExpressionStatementResolver],\n  [\"VariableDeclaration\", VariableDeclarationResolver],\n  [\"FunctionDeclaration\", FunctionDeclarationResolver],\n  [\"IfStatement\", IfStatementResolver],\n  [\"EmptyStatement\", EmptyStatementResolver],\n  [\"BlockStatement\", BlockStatementResolver],\n  [\"NewExpression\", NewExpressionResolver],\n  [\"LogicalExpression\", LogicalExpressionResolver],\n  [\"TryStatement\", TryStatementResolver],\n  [\"ThrowStatement\", ThrowStatementResolver],\n  [\"DoWhileStatement\", DoWhileStatementResolver],\n  [\"UpdateExpression\", UpdateExpressionResolver],\n  [\"UnaryExpression\", UnaryExpressionResolver]\n]);\n","import {\n  isThrownValue,\n  EvaluationResult,\n  isReturnValue,\n  ExpressionEvaluationResult\n} from \"./types\";\nimport { ASTResolvers } from \"./ASTResolvers\";\nimport assert from \"assert\";\nimport {\n  TExecutionContext,\n  ExecutionContext\n} from \"./execution-context/ExecutionContext\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { parseECMACompliant } from \"./parseECMACompliant\";\nimport { ESTree, parseScript } from \"cherow\";\n\nexport class ASTEvaluationError extends Error {\n  constructor(err: Error, public ast: ESTree.Node) {\n    super(err.message);\n    this.stack = err.stack;\n  }\n}\n\nexport class CodeEvaluationError extends ASTEvaluationError {\n  constructor(astError: ASTEvaluationError, public code: string) {\n    super(astError, astError.ast);\n    this.stack = astError.stack;\n  }\n}\n\nexport type NodeEvaluationResult<\n  T extends ESTree.Node\n> = T extends ESTree.Expression\n  ? [ExpressionEvaluationResult, TExecutionContext]\n  : [EvaluationResult, TExecutionContext];\n\nexport function evaluate<T extends ESTree.Node>(\n  ast: T,\n  execContext: TExecutionContext\n): NodeEvaluationResult<T> {\n  try {\n    const resolver = ASTResolvers.get(ast.type);\n    assert(resolver, `Can't resolve type of ast type ${ast.type}`);\n    const resultIter = resolver!(ast, execContext || ExecutionContext({}));\n\n    return unsafeCast<NodeEvaluationResult<T>>(\n      evaluateThrowableIterator(resultIter)\n    );\n  } catch (err) {\n    if (\n      err instanceof ASTEvaluationError ||\n      err instanceof CodeEvaluationError\n    ) {\n      throw err;\n    }\n    throw new ASTEvaluationError(err, ast);\n  }\n}\n\nexport function evaluateCode(code: string, execContext: TExecutionContext) {\n  try {\n    return evaluate(parseECMACompliant(code), execContext);\n  } catch (err) {\n    if (err instanceof CodeEvaluationError) {\n      throw err;\n    } else if (err instanceof ASTEvaluationError) {\n      throw new CodeEvaluationError(err, code);\n    }\n    throw err;\n  }\n}\n\nexport function evaluateCodeAsExpression(\n  code: string,\n  execContext: TExecutionContext\n) {\n  return evaluate(parseScript(code), execContext);\n}\n\nexport function evaluateThrowableIterator<\n  T extends Iterator<[EvaluationResult, TExecutionContext]>\n>(itr: T) {\n  let currentEvaluationResult = itr.next();\n  while (\n    !isThrownValue(currentEvaluationResult.value[0]) &&\n    !isReturnValue(currentEvaluationResult.value[0]) &&\n    !currentEvaluationResult.done\n  ) {\n    currentEvaluationResult = itr.next(currentEvaluationResult.value);\n  }\n\n  return currentEvaluationResult.value;\n}\n","import { ESString } from \"../string/String\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { Any } from \"../types\";\n\nexport function* prompt(\n  _sefl: Any,\n  _args: Array<Any>,\n  execContext: TExecutionContext\n) {\n  return [ESString(), execContext];\n}\n","import { Any, isESString, NotANumber, TESNumber } from \"../types\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\n\nexport function* round(\n  _self: any,\n  args: [TESNumber, ...Array<Any>],\n  execContext: TExecutionContext\n) {\n  if (!args[0] || isESString(args[0])) {\n    return [NotANumber, execContext];\n  } else {\n    return [\n      {\n        number: Math.round(unsafeCast<number>(args[0].value))\n      },\n      execContext\n    ];\n  }\n}\n","import { round } from \"./round\";\n\nexport const Math = {\n  properties: {\n    round: {\n      implementation: round\n    }\n  }\n};\n","import { ESFunction } from \"../Function/Function\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { Any, Undefined } from \"../types\";\nimport { tuple } from \"@deaven/tuple\";\nimport { TESString } from \"../string/String\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { evaluate } from \"../evaluate\";\nimport { parseECMACompliant } from \"../parseECMACompliant\";\n\nexport const evalFn = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext: TExecutionContext\n) {\n  const source = unsafeCast<string>(unsafeCast<TESString>(args[0]).value);\n  const parsedSource = parseECMACompliant(source);\n  const statements = parsedSource.body;\n\n  let currentEvaluationResult = tuple(Undefined, execContext);\n  for (const statement of statements.slice(0, statements.length - 1)) {\n    currentEvaluationResult = yield evaluate(\n      statement,\n      currentEvaluationResult[1]\n    );\n  }\n\n  const lastStatement = statements[statements.length - 1];\n\n  if (lastStatement.type === \"ExpressionStatement\") {\n    return evaluate(lastStatement.expression, currentEvaluationResult[1]);\n  }\n\n  return evaluate(lastStatement, currentEvaluationResult[1]);\n});\n","import { ESFunction } from \"../Function/Function\";\nimport { Any } from \"../types\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\n\nexport const NumberConstructor = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext\n) {\n  return [args[0], execContext] as [Any, TExecutionContext];\n});\n","import { ESFunction } from \"../Function/Function\";\nimport { Any } from \"../types\";\nimport { tuple } from \"@deaven/tuple\";\n\nexport const ObjectConstructor = ESFunction(function*(\n  _self: Any,\n  args: Any[],\n  execContext\n) {\n  return tuple(args[0], execContext);\n});\n","import { FunctionConstructor } from \"../Function/Function\";\nimport { Math } from \"../math/Math\";\nimport { evalFn } from \"../eval/eval\";\nimport { StringConstructor } from \"../string/String\";\nimport { NumberConstructor } from \"../number/Number\";\nimport { ESBooleanConstructor } from \"../boolean/ESBoolean\";\nimport { ObjectConstructor } from \"../Object/ObjectConstructor\";\n\nexport const ESInitialGlobal = {\n  properties: {\n    Math,\n    Function: FunctionConstructor,\n    eval: evalFn,\n    String: StringConstructor,\n    Number: NumberConstructor,\n    Boolean: ESBooleanConstructor,\n    Object: ObjectConstructor\n  }\n};\n","import { ESFunction } from \"../Function/Function\";\nimport { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { Any, WithProperties, Undefined } from \"../types\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { tuple } from \"@deaven/tuple\";\n\nexport const SyntaxErrorConstructor = ESFunction(function*(\n  self: Any,\n  args: Any[],\n  execContext: TExecutionContext\n) {\n  unsafeCast<WithProperties>(self).properties.message = args[0];\n  return tuple(Undefined, execContext);\n});\n\n// @ts-ignore\nSyntaxErrorConstructor.properties.prototype.properties.toString = ESFunction(\n  function*(self: Any, _args: Any[], execContext: TExecutionContext) {\n    return tuple(\n      unsafeCast<WithProperties>(self).properties.message,\n      execContext\n    );\n  }\n);\n","import {\n  TExecutionContext,\n  ExecutionContext\n} from \"../execution-context/ExecutionContext\";\nimport { Any, ThrownValue } from \"../types\";\nimport produce from \"immer\";\nimport { evaluateCode } from \"../evaluate\";\nimport { TESString, ESString } from \"../string/String\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { ESInitialGlobal } from \"../execution-context/ESInitialGlobal\";\nimport { TESObject, ESObject, createNewObjectFromConstructor } from \"../Object\";\nimport { tuple } from \"@deaven/tuple\";\nimport { SyntaxErrorConstructor } from \"../error/SyntaxError\";\n\nexport const vm = {\n  properties: {\n    createContext: {\n      parameters: [],\n      function: {\n        implementation: function*(\n          _self: Any,\n          args: Array<Any>,\n          execContext: TExecutionContext\n        ) {\n          return [args[0], execContext];\n        }\n      }\n    },\n    runInContext: {\n      parameters: [],\n      function: {\n        implementation: function*(\n          _self: Any,\n          args: Array<Any>,\n          execContext: TExecutionContext\n        ) {\n          const evalExecContext = ExecutionContext(\n            produce(execContext.value, draft => {\n              draft.global = ESObject({\n                ...ESInitialGlobal.properties,\n                ...unsafeCast<TESObject>(args[1]).properties\n              });\n            })\n          );\n          try {\n            return evaluateCode(\n              unsafeCast<string>(unsafeCast<TESString>(args[0]).value),\n              evalExecContext\n            );\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              const [\n                syntaxError,\n                afterErrorExecContext\n              ] = yield* createNewObjectFromConstructor(\n                SyntaxErrorConstructor,\n                [ESString(err.stack)],\n                evalExecContext\n              );\n              return tuple(ThrownValue(syntaxError), afterErrorExecContext);\n            }\n            throw err;\n          }\n        }\n      }\n    }\n  }\n};\n","import { vm } from \"./vm\";\n\nexport const NodeBuiltinModules = new Map([[\"vm\", vm]]);\n","import { TExecutionContext } from \"../execution-context/ExecutionContext\";\nimport { Any } from \"../types\";\nimport { NodeBuiltinModules } from \"../node-builtin-modules/NodeBuiltInModules\";\nimport { unsafeCast } from \"@deaven/unsafe-cast.macro\";\nimport { TESString } from \"../string/String\";\n\nexport const requireFunction = {\n  parameters: [],\n  function: {\n    implementation: function*(\n      _self: Any,\n      args: Array<Any>,\n      exeContext: TExecutionContext\n    ) {\n      return [\n        NodeBuiltinModules.get(\n          unsafeCast<string>(unsafeCast<TESString>(args[0]).value)\n        ),\n        exeContext\n      ];\n    }\n  }\n};\n","import { ExecutionContext } from \"./ExecutionContext\";\nimport { prompt } from \"../window/prompt\";\nimport { requireFunction } from \"../require/require\";\nimport { ESInitialGlobal } from \"./ESInitialGlobal\";\n\nexport const nodeInitialExecutionContext = ExecutionContext({\n  global: {\n    properties: {\n      ...ESInitialGlobal.properties,\n      prompt: {\n        parameters: [],\n        function: {\n          implementation: prompt\n        }\n      }\n    }\n  },\n  scope: {\n    require: requireFunction\n  }\n});\n"],"names":["NotANumber","Number","ESNull","type","isESNull","arg","Undefined","isUndefined","isESString","isArray","ESNumber","value","id","ValueIdentifier","properties","isESNumber","isFunction","isObject","keys","length","ReturnValue","isReturnValue","ThrownValue","isThrownValue","isESBoolean","reverse","self","_args","execContext","Array","map","part","concrete","join","args","reduceArray","ESString","reduce","result","stringOfCurrentPart","stringToConcatTo","implementation","calculateLength","number","currentPartLength","gte","undefined","split","string","substr","first","ExecutionContext","setCurrentThisValue","val","thisValue","setVariableInScope","name","scope","ESObject","isESObject","createNewObjectFromConstructor","calleeType","argsTypes","currExecContext","afterCallExecContext","function","tuple","prototype","parseECMACompliant","code","parseScript","loc","ESFunction","isESFunction","FunctionConstructor","_self","blockStatement","body","expression","createFunction","statements","params","atferParametersInScopeExecContext","prevContext","parameter","index","currentEvaluationResult","statement","evaluate","toString","StringConstructor","ESBoolean","coerceToBoolean","unimplemented","ESBooleanConstructor","plus","left","right","minus","greaterThan","exactEquality","notExactEquality","logicalAnd","_","leftType","afterLeftExecContext","leftTypeAsBoolean","rightType","afterRightExecContext","rightTypeAsBoolean","logicalOr","_right","equal","notEqual","not","argAsBoolean","typeOf","unaryMinus","unaryVoid","BinaryOperatorResolvers","Map","LogicalOperatorResolvers","UnaryOperatorResolvers","noExecutionContextResolver","fn","ast","statementResolver","resultIter","evaluateThrowableIterator","IdentifierResolver","resolvedFromScope","global","LiteralResolver","MemberExpressionResolver","objectType","newExecContext","object","propertyType","property","CallExpressionResolver","callee","argAST","arguments","argType","BinaryExpressionResolver","leftExecContext","rightExecContext","binaryOperatorResolver","get","operator","assert","ProgramResolver","programFunction","programIter","resultAsString","resultExecContext","stderr","BlockStatementResolver","AssignmentExpressionResolver","ReturnStatementResolver","isNull","argument","afterArgExecContext","ThisExpressionResolver","_ast","ObjectExpressionResolver","obj","propValueType","shorthand","key","FunctionExpressionResolver","functionType","ExpressionStatementResolver","VariableDeclarationResolver","declaration","declarations","init","initResult","FunctionDeclarationResolver","IfStatementResolver","testType","afterTestExecContext","test","testTypeAsBoolean","consequentExecContext","consequent","alternate","EmptyStatementResolver","NewExpressionResolver","LogicalExpressionResolver","logicalOperatorResolver","TryStatementResolver","tryBlockEvaluationResult","block","preCatchHandlerExecContext","handler","param","ThrowStatementResolver","DoWhileStatementResolver","_statement","UpdateExpressionResolver","argTypeAfterUpdate","afterUpdateExecContext","UnaryExpressionResolver","unaryOperatorResolver","ASTResolvers","ASTEvaluationError","Error","constructor","err","message","stack","CodeEvaluationError","astError","resolver","evaluateCode","evaluateCodeAsExpression","itr","next","done","prompt","_sefl","round","Math","evalFn","source","parsedSource","slice","lastStatement","NumberConstructor","ObjectConstructor","ESInitialGlobal","Function","eval","String","Boolean","Object","SyntaxErrorConstructor","vm","createContext","parameters","runInContext","evalExecContext","produce","draft","SyntaxError","syntaxError","afterErrorExecContext","NodeBuiltinModules","requireFunction","exeContext","nodeInitialExecutionContext","require"],"mappings":";;;;;;;;;;;;;;;;MAMaA,UAAU,GAAG,EAAnB;AACP,AAAO,MAAMC,MAAM,GAAG,EAAf;AACP,AAMO,MAAMC,MAAe,GAAG;EAC7BC,IAAI,EAAE;CADD;AAIP,AAAO,SAASC,QAAT,CAAkBC,GAAlB,EAA4C;SAC1CA,GAAG,CAACF,IAAJ,KAAa,MAApB;;AAGF,AAAO,MAAMG,SAAuB,GAAG;EACrCH,IAAI,EAAE;CADD;AAIP,AAAO,SAASI,WAAT,CAAqBF,GAArB,EAAoD;SAClDA,GAAG,CAACF,IAAJ,KAAa,WAApB;;AAGF,AAAO,SAASK,UAAT,CAAoBH,GAApB,EAAgD;SAC9CA,GAAG,CAACF,IAAJ,KAAa,QAApB;;AAGF,AAAO,SAASM,OAAT,CAAiBJ,GAAjB,EAA2B;SACzBA,GAAG,CAACF,IAAJ,KAAa,OAApB;;AAKF,AAAO,SAASO,QAAT,CAAkBC,KAAlB,EAA6C;SAC3C;IACLR,IAAI,EAAE,QADD;IAELS,EAAE,EAAEC,eAAe,EAFd;IAGLC,UAAU,EAAE,EAHP;IAILH;GAJF;;AAQF,AAAO,SAASI,UAAT,CAAoBV,GAApB,EAAgD;SAC9CA,GAAG,CAACF,IAAJ,KAAa,QAApB;;AAiBF,AAAO,SAASa,UAAT,CAAoBX,GAApB,EAA+C;SAElDY,eAAQ,CAACZ,GAAD,CAAR,IAAiBa,WAAI,CAACb,GAAD,CAAJ,CAAUc,MAAV,KAAqB,CAAtC,IAA2CD,WAAI,CAACb,GAAD,CAAJ,CAAU,CAAV,MAAiB,gBAD9D;;AAgBF,AAAO,SAASQ,eAAT,GAA2B;SACzB,EAAP;;AAmBF,AAAO,SAASO,WAAT,CAAqBT,KAArB,EAAiC;SAC/B;IACLR,IAAI,EAAE,aADD;IAELQ;GAFF;;AAMF,AAAO,SAASU,aAAT,CAAuBhB,GAAvB,EAAsD;SACpDA,GAAG,CAACF,IAAJ,KAAa,aAApB;;AAQF,AAAO,SAASmB,WAAT,CAAqBX,KAArB,EAAiC;SAC/B;IACLR,IAAI,EAAE,aADD;IAELQ;GAFF;;AAMF,AAAO,SAASY,aAAT,CAAuBlB,GAAvB,EAAsD;SACpDA,GAAG,CAACF,IAAJ,KAAa,aAApB;;AAOF,AAAO,SAASqB,WAAT,CAAqBnB,GAArB,EAAkD;SACvBA,GAAzB,CAA8BF,IAA9B,KAAuC,SAA9C;;;ACpIK,UAAUsB,OAAV,CACLC,IADK,EAELC,KAFK,EAGLC,WAHK,EAIL;SACO,CACLC,KAAK,CACFH,IAAI,CAACf,KAAN,CAAmCc,OAAnC,GAA6CK,GAA7C,CAAiDC,IAAI,IAAI;QACnDtB,OAAO,CAACsB,IAAD,CAAP,IAAiBA,IAAI,CAACpB,KAA1B,EAAiC;aACxBkB,KAAK,CAACE,IAAI,CAACpB,KAAL,CAAWc,OAAX,EAAD,EAAuBM,IAAI,CAACC,QAA5B,CAAZ;;;WAEKD,IAAP;GAJF,CADG,EAOHL,IAAI,CAACM,QAPF,CADA,EAULJ,WAVK,CAAP;;;ACHK,UAAUK,IAAV,CACLP,IADK,EAELQ,IAFK,EAGLN,WAHK,EAIL;QACMO,WAAW,GAAI9B,GAAD,IAAiC;QAC/C,CAACA,GAAG,CAACM,KAAT,EAAgB;aACPyB,QAAQ,EAAf;;;WAEM/B,GAAG,CAACM,KAAL,CAAkC0B,MAAlC,CAAyC,CAACC,MAAD,EAASP,IAAT,KAAkB;UAC5DQ,mBAAJ;;UACI9B,OAAO,CAACsB,IAAD,CAAX,EAAmB;QACjBQ,mBAAmB,GAAGJ,WAAW,CAACJ,IAAD,CAAjC;OADF,MAEO;QACLQ,mBAAmB,GAAGR,IAAtB;;;UAGES,gBAAgB,GAAGF,MAAvB;;UAEE,CAAC/B,kBAAW,CAACiC,gBAAgB,CAAC7B,KAAlB,CAAZ,IACA,CAACJ,kBAAW,CAACgC,mBAAmB,CAAC5B,KAArB,CAFd,EAGE;QACA6B,gBAAgB,CAAC7B,KAAjB,GACG6B,gBAAgB,CAAC7B,KAAlB,GACAuB,IAAI,CAAC,CAAD,CAAJ,CAAQvB,KADR,GAEA4B,mBAAmB,CAAC5B,KAHtB;eAIO2B,MAAP;OARF,MASO;eACEF,QAAQ,CAAC,CAACE,MAAD,EAASC,mBAAT,CAAD,CAAf;;KAnBG,EAqBJH,QAAQ,CAAC,EAAD,CArBJ,CAAP;GAJF;;SA4BO,CAACD,WAAW,CAACT,IAAD,CAAZ,EAAoBE,WAApB,CAAP;;;AC7BK,SAASC,KAAT,CACLlB,KADK,EAELqB,QAFK,EAGL;SACO;IACL7B,IAAI,EAAE,OADD;IAELW,UAAU,EAAE;MACVW,OAAO,EAAE;QACPgB,cAAc,EAAEhB;OAFR;MAIVQ,IAAI,EAAE;QACJQ,cAAc,EAAER;OALR;MAOVd,MAAM,EAAEuB,eAAe,CAAC/B,KAAD,EAAQqB,QAAR;KATpB;IAWLrB,KAXK;IAYLqB;GAZF;;;AAgBF,SAASU,eAAT,CACE/B,KADF,EAEEqB,QAFF,EAGiD;MAC3C,CAACrB,KAAL,EAAY;WACHV,MAAP;;;MAEE+B,QAAJ,EAAc;WACL;MAAEW,MAAM,EAAEhC,KAAK,CAACQ;KAAvB;;;SAEoCR,KAA/B,CAAsC0B,MAAtC,CACL,CAACC,MAAD,EAASP,IAAT,KAAkB;QACZ,CAACO,MAAL,EAAa;aACJI,eAAe,CAACX,IAAI,CAACpB,KAAN,EAAaoB,IAAI,CAACC,QAAlB,CAAtB;KADF,MAEO;YACCY,iBAAiB,GAAGF,eAAe,CAACX,IAAI,CAACpB,KAAN,EAAaoB,IAAI,CAACC,QAAlB,CAAzC;;UACIY,iBAAiB,KAAK3C,MAA1B,EAAkC;eACzB;UACL4C,GAAG,EAAwBP,MAAtB,CAA8B3B;SADrC;;;aAIK;QACLkC,GAAG,EAAwBD,iBAAtB,CAAyCjC;OADhD;;GAXC,EAgBJmC,SAhBI,CAAP;;;ACnCK,UAAUC,KAAV,CACLrB,IADK,EAELQ,IAFK,EAGLN,WAHK,EAIL;SACO,CACLC,KAAK,CACFH,IAAI,CAACf,KAAN,CAAiCmB,GAAjC,CAAqCC,IAAI,IAAI;QACvCA,IAAI,CAACpB,KAAT,EAAgB;aACPkB,KAAK,CACTE,IAAI,CAACpB,KAAN,CACGoC,KADH,CACSb,IAAI,CAAC,CAAD,CAAJ,CAAQvB,KADjB,EAEGmB,GAFH,CAEOkB,MAAM,IAAIZ,QAAQ,CAACY,MAAD,CAFzB,CADU,EAIV,IAJU,CAAZ;;;WAOKnB,KAAK,EAAZ;GATF,CADG,CADA,EAcLD,WAdK,CAAP;;;ACJK,UAAUqB,MAAV,CACLvB,IADK,EAELQ,IAFK,EAGLN,WAHK,EAIL;SACO,CACLQ,QAAQ,CACJc,YAAK,CAACxB,IAAI,CAACf,KAAN,CAAN,CACEA,KADH,CACoBsC,MADpB,CAEqBf,IAAI,CAAC,CAAD,CAAJ,CAAQvB,KAF7B,EAGqBuB,IAAI,CAAC,CAAD,CAAJ,CAAQvB,KAH7B,CADM,CADH,EAQLiB,WARK,CAAP;;;ACGK,SAASuB,gBAAT,CAA0BxC,KAA1B,EAAsC;SACpC;IACLR,IAAI,EAAE,kBADD;IAELQ;GAFF;;AAMF,AAAO,SAASyC,mBAAT,CACLxB,WADK,EAELyB,GAFK,EAGc;SACZF,gBAAgB,CAAC,EAAE,GAAGvB,WAAW,CAACjB,KAAjB;IAAwB2C,SAAS,EAAED;GAApC,CAAvB;;AAGF,AAAO,SAASE,kBAAT,CACL3B,WADK,EAEL4B,IAFK,EAGLH,GAHK,EAIL;SACOF,gBAAgB,CAAC,EACtB,GAAGvB,WAAW,CAACjB,KADO;IAEtB8C,KAAK,EAAE,EAAE,GAAG7B,WAAW,CAACjB,KAAZ,CAAkB8C,KAAvB;OAA+BD,IAAD,GAAQH;;GAFxB,CAAvB;;;ACZK,SAASK,QAAT,CAAkB/C,KAAlB,EAA6D;SAC3D;IACLR,IAAI,EAAE,QADD;IAELS,EAAE,EAAEC,eAAe,EAFd;IAGLC,UAAU,EAAEH,KAAK,IAAI,EAHhB;IAILA;GAJF;;AAQF,AAAO,SAASgD,UAAT,CAAoBtD,GAApB,EAAgD;SAC9CA,GAAG,CAACF,IAAJ,KAAa,QAApB;;AAGF,AAAO,UAAUyD,8BAAV,CACLC,UADK,EAELC,SAFK,EAGLlC,WAHK,EAIL;QACM0B,SAAS,GAAGI,QAAQ,CAAC,EAAD,CAA1B;QACMK,eAAe,GAAGX,mBAAmB,CAACxB,WAAD,EAAc0B,SAAd,CAA3C;QAEM,GAAGU,oBAAH,IAA2B,OAAOH,UAAU,CAACI,QAAX,CAAoBxB,cAApB,CACtCa,SADsC,EAEtCQ,SAFsC,EAGtCC,eAHsC,CAAxC;SAMOG,WAAK,CACVR,QAAQ,CAAC,EACP,GAAyBG,UAAU,CAAC/C,UAAX,CAAsBqD,SAA5C,CAAuDrD,UADnD;OAEkBkD,oBAAoB,CAACrD,KAArB,CAA2B2C,SAAjD,CAA4D3C;GAFzD,CADE,EAKVqD,oBALU,CAAZ;;;AC9CK,SAASI,kBAAT,CAA4BC,IAA5B,EAA0D;SACxDC,kBAAW,CAACD,IAAD,EAAO;IAAEE,GAAG,EAAE;GAAd,CAAlB;;;ACiBK,SAASC,UAAT,CAAoB/B,cAApB,EAA4D;SAC1D;IACLtC,IAAI,EAAE,UADD;IAELW,UAAU,EAAE;MACVqD,SAAS,EAAET,QAAQ;KAHhB;IAKLO,QAAQ,EAAE;MACRxB;;GANJ;;AAWF,AAAO,SAASgC,YAAT,CAAsBpE,GAAtB,EAAwD;SACtDA,GAAG,CAACF,IAAJ,KAAa,UAApB;;AAGF,AAAO,MAAMuE,mBAAmB,GAAGF,UAAU,CAAC,WAC5CG,KAD4C,EAE5CzC,IAF4C,EAG5CN,WAH4C,EAI5C;QACMgD,cAAc,GAAKR,kBAAkB,CACxC,UAA+BlC,IAAI,CAAC,CAAD,CAA1B,CAA+BvB,KAAgB,GADhB,CAAlB,CAEvBkE,IAFuB,CAElB,CAFkB,CAAD,CAGrBC,UAHoB,CAIpBD,IAJH;SAKO,CAACE,cAAc,CAACH,cAAc,CAACC,IAAhB,EAAsB,EAAtB,CAAf,EAA0CjD,WAA1C,CAAP;CAV2C,CAAtC;AAgBP,AAAO,SAASmD,cAAT,CACLC,UADK,EAELC,MAFK,EAGL;SACO;IACL9E,IAAI,EAAE,UADD;IAELW,UAAU,EAAE;MACVqD,SAAS,EAAET,QAAQ;KAHhB;IAKLO,QAAQ,EAAE;MACRxB,cAAc,EAAE,WACdkC,KADc,EAEdzC,IAFc,EAGdN,WAHc,EAId;cACMsD,iCAAiC,GAAGD,MAAM,CAAC5C,MAAP,CACxC,CAAC8C,WAAD,EAAcC,SAAd,EAAyBC,QAAzB,KACE9B,kBAAkB,CAChB4B,WADgB,EAEcC,SAA9B,CAAyC5B,IAFzB,EAGhBtB,IAAI,CAACmD,QAAD,CAHY,CAFoB,EAOxCzD,WAPwC,CAA1C;YAUI0D,uBAAuB,GAAGpB,WAAK,CACjC5D,SADiC,EAEjC4E,iCAFiC,CAAnC;;aAKK,MAAMK,SAAX,IAAwBP,UAAxB,EAAoC;UAClCM,uBAAuB,GAAGE,QAAQ,CAChCD,SADgC,EAEhCD,uBAAuB,CAAC,CAAD,CAFS,CAAlC;;cAIIjE,aAAa,CAACiE,uBAAuB,CAAC,CAAD,CAAxB,CAAjB,EAA+C;mBACtCpB,WAAK,CACVoB,uBAAuB,CAAC,CAAD,CAAvB,CAA2B3E,KADjB,EAEV2E,uBAAuB,CAAC,CAAD,CAFb,CAAZ;WADF,MAKO;kBACCA,uBAAN;;;;eAIGpB,WAAK,CAAC5D,SAAD,EAAYgF,uBAAuB,CAAC,CAAD,CAAnC,CAAZ;;;GAzCN;;;ACpCK,SAASlD,QAAT,CAAkBzB,KAAlB,EAAgE;SAC9D;IACLR,IAAI,EAAE,QADD;IAELS,EAAE,EAAEC,eAAe,EAFd;IAGLC,UAAU,EAAE;MACV2E,QAAQ,EAAE;QACRxB,QAAQ,EAAE;UACRxB,cAAc,EAAE,WACdf,IADc,EAEdC,KAFc,EAGdC,WAHc,EAId;mBACO,CAACF,IAAD,EAAOE,WAAP,CAAP;;;OARI;MAYVmB,KAAK,EAAE;QACLN,cAAc,EAAEM;OAbR;MAeVE,MAAM,EAAE;QACNR,cAAc,EAAEQ;OAhBR;MAkBV9B,MAAM,EAAEuB,iBAAe,CAAC/B,KAAD;KArBpB;IAuBLA;GAvBF;;AA2BF,AAAO,MAAM+E,iBAAiB,GAAGlB,UAAU,CAAC,WAC1CG,KAD0C,EAE1CzC,IAF0C,EAG1CN,WAH0C,EAI1C;SACO,CAACM,IAAI,CAAC,CAAD,CAAL,EAAUN,WAAV,CAAP;CALyC,CAApC;;AAQP,SAASc,iBAAT,CACE/B,KADF,EAEiD;MAC3C,CAACA,KAAL,EAAY;WACHV,MAAP;;;MAEE,OAAOU,KAAP,KAAiB,QAArB,EAA+B;WACtB;MAAEgC,MAAM,EAAEhC,KAAK,CAACQ;KAAvB;;;SAEKR,KAAK,CAAC0B,MAAN,CACL,CAACC,MAAD,EAASP,IAAT,KAAkB;QACZ,CAACO,MAAL,EAAa;aACJI,iBAAe,CAACX,IAAI,CAACpB,KAAN,CAAtB;KADF,MAEO;aACE;QACLkC,GAAG,EAAGP,MAAD,CAAsB3B;OAD7B;;GALC,EAUJmC,SAVI,CAAP;;;ACjDK,SAAS6C,SAAT,CAAmBhF,KAAnB,EAAgD;SAC9C;IACLR,IAAI,EAAE,SADD;IAELS,EAAE,EAAEC,eAAe,EAFd;IAGLC,UAAU,EAAE,EAHP;IAILH;GAJF;;AAQF,AAAO,SAASiF,eAAT,CAAyBvC,GAAzB,EAA+C;MAChD7B,WAAW,CAAC6B,GAAD,CAAf,EAAsB;WACbA,GAAP;;;MAGEtC,UAAU,CAACsC,GAAD,CAAd,EAAqB;WACZ,OAAOA,GAAG,CAAC1C,KAAX,KAAqB,QAArB,GACH0C,GAAG,CAAC1C,KAAJ,KAAc,CAAd,GACEgF,SAAS,CAAC,KAAD,CADX,GAEEA,SAAS,CAAC,IAAD,CAHR,GAIHA,SAAS,EAJb;;;MAOEvF,QAAQ,CAACiD,GAAD,CAAR,IAAiB9C,WAAW,CAAC8C,GAAD,CAAhC,EAAuC;WAC9BsC,SAAS,CAAC,KAAD,CAAhB;;;MAGEnF,UAAU,CAAC6C,GAAD,CAAd,EAAqB;WACZ,OAAOA,GAAG,CAAC1C,KAAX,KAAqB,QAArB,GACH0C,GAAG,CAAC1C,KAAJ,KAAc,EAAd,GACEgF,SAAS,CAAC,KAAD,CADX,GAEEA,SAAS,CAAC,IAAD,CAHR,GAIHE,mBAAa,EAJjB;;;MAOElC,UAAU,CAACN,GAAD,CAAd,EAAqB;WACZsC,SAAS,CAAC,IAAD,CAAhB;;;MAGElB,YAAY,CAACpB,GAAD,CAAhB,EAAuB;WACdsC,SAAS,CAAC,IAAD,CAAhB;;;SAGKE,mBAAa,EAApB;;AAGF,AAAO,MAAMC,oBAAoB,GAAGtB,UAAU,CAAC,WAC7CG,KAD6C,EAE7CzC,IAF6C,EAG7CN,WAH6C,EAI7C;SACO,CAACgE,eAAe,CAAC1D,IAAI,CAAC,CAAD,CAAJ,IAAW5B,SAAZ,CAAhB,EAAwCsB,WAAxC,CAAP;CAL4C,CAAvC;;AC1BA,SAASmE,IAAT,CAAcC,IAAd,EAAyBC,KAAzB,EAAqC;MACtCzF,UAAU,CAACwF,IAAD,CAAV,IAAoB,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,QAA9C,EAAwD;QAClDH,UAAU,CAACyF,KAAD,CAAd,EAAuB;aACd7D,QAAQ,CAAC4D,IAAI,CAACrF,KAAL,GAAasF,KAAK,CAACtF,KAApB,CAAf;;;WAEKyB,QAAQ,CAAC4D,IAAI,CAACrF,KAAL,GAAa,MAAd,CAAf;;;SAEKyB,QAAQ,CAAC,CAAuB4D,IAAvB,EAAoDC,KAApD,CAAD,CAAf;;AAGF,AAAO,SAASC,KAAT,CAAeF,IAAf,EAA0BC,KAA1B,EAAsC;MAEzClF,UAAU,CAACiF,IAAD,CAAV,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,QADtB,IAEAI,UAAU,CAACkF,KAAD,CAFV,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,QAJzB,EAKE;WACOD,QAAQ,CAACsF,IAAI,CAACrF,KAAL,GAAasF,KAAK,CAACtF,KAApB,CAAf;;;SAGKkF,mBAAa,EAApB;;AAGF,AAAO,SAASM,WAAT,CAAqBH,IAArB,EAAgCC,KAAhC,EAA4C;SAEjBD,IAA9B,CAAoCnD,GAApC,GACyCoD,KAAtB,CAA6BtF,KAFlD;;AAMF,AAAO,SAASyF,aAAT,CAAuBJ,IAAvB,EAAkCC,KAAlC,EAA8C;MAC/C1F,WAAW,CAACyF,IAAD,CAAX,IAAqBzF,WAAW,CAAC0F,KAAD,CAApC,EAA6C;WACpCN,SAAS,CAAC,IAAD,CAAhB;;;MAIA5E,UAAU,CAACiF,IAAD,CAAV,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,QADtB,IAEAI,UAAU,CAACkF,KAAD,CAFV,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,QAJzB,EAKE;WACOgF,SAAS,CAACK,IAAI,CAACrF,KAAL,KAAesF,KAAK,CAACtF,KAAtB,CAAhB;;;SAGKgF,SAAS,CACaK,IAA3B,CAAiCpF,EAAjC,KAAmEqF,KAA3B,CAAkCrF,EAD5D,CAAhB;;AAKF,AAAO,SAASyF,gBAAT,CAA0BL,IAA1B,EAAqCC,KAArC,EAAiD;MAClD1F,WAAW,CAACyF,IAAD,CAAf,EAAuB;QACjBzF,WAAW,CAAC0F,KAAD,CAAf,EAAwB;aACfN,SAAS,CAAC,KAAD,CAAhB;KADF,MAEO;aACEA,SAAS,CAAC,IAAD,CAAhB;;;;MAIF5E,UAAU,CAACiF,IAAD,CAAV,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,QADtB,IAEAI,UAAU,CAACkF,KAAD,CAFV,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,QAJzB,EAKE;WACOgF,SAAS,CAACK,IAAI,CAACrF,KAAL,KAAesF,KAAK,CAACtF,KAAtB,CAAhB;;;MAIAH,UAAU,CAACwF,IAAD,CAAV,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,QADtB,IAEAH,UAAU,CAACyF,KAAD,CAFV,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,QAJzB,EAKE;WACOgF,SAAS,CAACK,IAAI,CAACrF,KAAL,KAAesF,KAAK,CAACtF,KAAtB,CAAhB;;;MAIAa,WAAW,CAACwE,IAAD,CAAX,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,SADtB,IAEAa,WAAW,CAACyE,KAAD,CAFX,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,SAJzB,EAKE;WACOgF,SAAS,CAACK,IAAI,CAACrF,KAAL,KAAesF,KAAK,CAACtF,KAAtB,CAAhB;;;SAGKgF,SAAS,CACaK,IAA3B,CAAiCpF,EAAjC,KAAmEqF,KAA3B,CAAkCrF,EAD5D,CAAhB;;AAKF,AAAO,MAAM0F,UAAU,GAAGC,YAAC,CAA0B,WACnDP,IADmD,EAEnDC,KAFmD,EAGnDrE,WAHmD,EAInD;QACM,CAAC4E,QAAD,EAAWC,oBAAX,IAAmC,MAAMjB,QAAQ,CAACQ,IAAD,EAAOpE,WAAP,CAAvD;QACM8E,iBAAiB,GAAGd,eAAe,CAACY,QAAD,CAAzC;;MACIE,iBAAiB,CAAC/F,KAAlB,KAA4B,IAAhC,EAAsC;UAC9B,CAACgG,SAAD,EAAYC,qBAAZ,IAAqC,MAAMpB,QAAQ,CACvDS,KADuD,EAEvDQ,oBAFuD,CAAzD;UAIMI,kBAAkB,GAAGjB,eAAe,CAACe,SAAD,CAA1C;;QACIE,kBAAkB,CAAClG,KAAnB,KAA6B,IAAjC,EAAuC;aAC9B,CAACgG,SAAD,EAAYC,qBAAZ,CAAP;;;WAGKf,mBAAa,EAApB;GAVF,MAWO,IAAIa,iBAAiB,CAAC/F,KAAlB,KAA4B,KAAhC,EAAuC;WACrC,CAAC6F,QAAD,EAAWC,oBAAX,CAAP;;;SAGKZ,mBAAa,EAApB;CAtByB,CAApB;AAyBP,AAAO,MAAMiB,SAAS,GAAGP,YAAC,CAA0B,WAClDP,IADkD,EAElDe,MAFkD,EAGlDnF,WAHkD,EAIlD;QACM,CAAC4E,QAAD,EAAWC,oBAAX,IAAmC,MAAMjB,QAAQ,CAACQ,IAAD,EAAOpE,WAAP,CAAvD;QACM8E,iBAAiB,GAAGd,eAAe,CAACY,QAAD,CAAzC;;MACIE,iBAAiB,CAAC/F,KAAlB,KAA4B,IAAhC,EAAsC;WAC7B,CAAC6F,QAAD,EAAWC,oBAAX,CAAP;;;SAGKZ,mBAAa,EAApB;CAXwB,CAAnB;AAcP,AAAO,MAAMmB,KAAK,GAAGT,YAAC,CAAyB,CAACP,IAAD,EAAOC,KAAP,KAAiB;MAE5DzE,WAAW,CAACwE,IAAD,CAAX,IACA,OAAOA,IAAI,CAACrF,KAAZ,KAAsB,SADtB,IAEAa,WAAW,CAACyE,KAAD,CAFX,IAGA,OAAOA,KAAK,CAACtF,KAAb,KAAuB,SAJzB,EAKE;WACOgF,SAAS,CAACK,IAAI,CAACrF,KAAL,IAAcsF,KAAK,CAACtF,KAArB,CAAhB;;;SAGKkF,mBAAa,EAApB;CAVoB,CAAf;AAaP,AAAO,MAAMoB,QAAQ,GAAGV,YAAC,CAAyB,CAACP,IAAD,EAAOC,KAAP,KAAiB;SAC1DN,SAAS,CACQK,IAAtB,CAA4BrF,KAA5B,IAA2DsF,KAAtB,CAA6BtF,KADpD,CAAhB;CADuB,CAAlB;AAMP,AAAO,MAAMuG,GAAG,GAAGX,YAAC,CAAwB,CAAClG,GAAD,EAAMuB,WAAN,KAAsB;QAC1DuF,YAAY,GAAGvB,eAAe,CAACvF,GAAD,CAApC;;MACI,OAAO8G,YAAY,CAACxG,KAApB,KAA8B,SAAlC,EAA6C;WACpCuD,WAAK,CAACyB,SAAS,CAAC,CAACwB,YAAY,CAACxG,KAAf,CAAV,EAAiCiB,WAAjC,CAAZ;;;SAGKiE,mBAAa,EAApB;CANkB,CAAb;AASP,AAAO,MAAMuB,MAAM,GAAGb,YAAC,CAAwB,CAAClG,GAAD,EAAMuB,WAAN,KAAsB;SAC5DsC,WAAK,CAAC9B,QAAQ,CAA0B/B,GAAzB,CAA8BF,IAA/B,CAAT,EAA+CyB,WAA/C,CAAZ;CADqB,CAAhB;AAIP,AAAO,MAAMyF,UAAU,GAAGd,YAAC,CAAwB,CAAClG,GAAD,EAAMuB,WAAN,KAAsB;SAChEsC,WAAK,CACVxD,QAAQ,CAAC,CAA0CL,GAAtB,CAA2BM,KAAhD,CADE,EAEViB,WAFU,CAAZ;CADyB,CAApB;AAOP,AAAO,MAAM0F,SAAS,GAAGf,YAAC,CAAwB,CAACA,CAAD,EAAI3E,WAAJ,KAAoB;SAC7DsC,WAAK,CAAC5D,SAAD,EAAYsB,WAAZ,CAAZ;CADwB,CAAnB;AAIP,AAAO,MAAM2F,uBAAuB,GAAG,IAAIC,GAAJ,CAAwC,CAC7E,CAAC,GAAD,EAAMrB,WAAN,CAD6E,EAE7E,CAAC,GAAD,EAAMJ,IAAN,CAF6E,EAG7E,CAAC,GAAD,EAAMG,KAAN,CAH6E,EAI7E,CAAC,KAAD,EAAQE,aAAR,CAJ6E,EAK7E,CAAC,KAAD,EAAQC,gBAAR,CAL6E,EAM7E,CAAC,IAAD,EAAOY,QAAP,CAN6E,EAO7E,CAAC,IAAD,EAAOD,KAAP,CAP6E,CAAxC,CAAhC;AAUP,AAAO,MAAMS,wBAAwB,GAAG,IAAID,GAAJ,CAGtC,CAAC,CAAC,IAAD,EAAOlB,UAAP,CAAD,EAAqB,CAAC,IAAD,EAAOQ,SAAP,CAArB,CAHsC,CAAjC;AAKP,AAAO,MAAMY,sBAAsB,GAAG,IAAIF,GAAJ,CAAuC,CAC3E,CAAC,GAAD,EAAMN,GAAN,CAD2E,EAE3E,CAAC,GAAD,EAAMG,UAAN,CAF2E,EAG3E,CAAC,QAAD,EAAWD,MAAX,CAH2E,EAI3E,CAAC,MAAD,EAASE,SAAT,CAJ2E,CAAvC,CAA/B;;AC7NP;AAEA,AA2CO,MAAMK,0BAA0B,GAIrCC,EAHA,IAKA,WAAUC,GAAV,EAAqBjG,WAArB,EAAqD;SAC5CsC,WAAK,CAAC0D,EAAE,CAACC,GAAD,EAAMjG,WAAN,CAAH,EAAuBA,WAAvB,CAAZ;CAPG;AAUP,AAAO,MAAMkG,iBAAiB,GAC5BF,EADgC,IAMhC,WAAUC,GAAV,EAA2BjG,WAA3B,EAA2D;QACnDmG,UAAU,GAAGH,EAAE,CAACC,GAAD,EAAMjG,WAAN,CAArB;SAEOoG,yBAAyB,CAACD,UAAD,CAAhC;CATG;AAYP,AAAO,MAAME,kBAGZ,GAAGN,0BAA0B,CAAC,CAACE,GAAD,EAAMjG,WAAN,KAAsB;QAC7CsG,iBAAiB,GAAGtG,WAAW,CAACjB,KAAZ,CAAkB8C,KAAlB,CAAwBoE,GAAG,CAACrE,IAA5B,CAA1B;SAEE0E,iBAAiB,IACjBtG,WAAW,CAACjB,KAAZ,CAAkBwH,MAAlB,CAAyBrH,UAAzB,CAAoC+G,GAAG,CAACrE,IAAxC,CADA,IAEAlD,SAHF;CAF4B,CAHvB;AAYP,AAAO,MAAM8H,eAGZ,GAAGT,0BAA0B,CAACE,GAAG,IAAI;MAChC,OAAOA,GAAG,CAAClH,KAAX,KAAqB,QAAzB,EAAmC;WAC1ByB,QAAQ,CAACyF,GAAG,CAAClH,KAAL,CAAf;GADF,MAEO,IAAI,OAAOkH,GAAG,CAAClH,KAAX,KAAqB,QAAzB,EAAmC;WACjCD,QAAQ,CAACmH,GAAG,CAAClH,KAAL,CAAf;GADK,MAEA,IAAI,OAAOkH,GAAG,CAAClH,KAAX,KAAqB,SAAzB,EAAoC;WAClCgF,SAAS,CAACkC,GAAG,CAAClH,KAAL,CAAhB;GADK,MAEA,IAAIkH,GAAG,CAAClH,KAAJ,KAAc,IAAlB,EAAwB;WACtBT,MAAP;;;SAGK2F,mBAAa,EAApB;CAX4B,CAHvB;AAiBP,AAAO,MAAMwC,wBAGZ,GAAG,WAAUR,GAAV,EAAejG,WAAf,EAA4B;QACxB,CAAC0G,UAAD,EAAaC,cAAb,IAA+B,MAAM/C,QAAQ,CAACqC,GAAG,CAACW,MAAL,EAAa5G,WAAb,CAAnD;QACM6G,YAAY,GAA8BH,UAA3B,CAAuCxH,UAAvC,CACW+G,GAAG,CAACa,QAAlC,CAA4ClF,IADzB,CAArB;;MAGIxC,UAAU,CAACyH,YAAD,CAAd,EAA8B;WACrBvE,WAAK,CACV;MACExC,IAAI,EAAE4G,UADR;MAEErE,QAAQ,EAAEwE;KAHF,EAKVF,cALU,CAAZ;GADF,MAQO;WACErE,WAAK,CAACuE,YAAD,EAAeF,cAAf,CAAZ;;CAjBG;AAqBP,AAAO,MAAMI,sBAGZ,GAAG,WAAUd,GAAV,EAAejG,WAAf,EAA4B;MAC1B,CAACiC,UAAD,EAAa0E,cAAb,IAA+B,MAAM/C,QAAQ,CAACqC,GAAG,CAACe,MAAL,EAAahH,WAAb,CAAjD;MAEImC,eAAe,GAAGwE,cAAtB;MACIzE,SAAgB,GAAG,EAAvB;;OAEK,MAAM+E,MAAX,IAAqBhB,GAAG,CAACiB,SAAzB,EAAoC;UAC5B,CAACC,OAAD,EAAUR,cAAV,IAA4B,MAAM/C,QAAQ,CAACqD,MAAD,EAAS9E,eAAT,CAAhD;IACAD,SAAS,GAAG,CAAC,GAAGA,SAAJ,EAAeiF,OAAf,CAAZ;IACAhF,eAAe,GAAGwE,cAAlB;;;EAGFxE,eAAe,GAAGX,mBAAmB,CACnCW,eADmC,EAEPF,UAA5B,CAAwCnC,IAAxC,IAAgDqC,eAAe,CAACpD,KAAhB,CAAsBwH,MAFnC,CAArC;SAKO,OAAmCtE,UAA5B,CAAwCI,QAAxC,CAAiDxB,cAAjD,CACgBoB,UAA5B,CAAwCnC,IAAxC,IACEqC,eAAe,CAACpD,KAAhB,CAAsBwH,MAFZ,EAGZrE,SAHY,EAIZC,eAJY,CAAd;CApBK;AA4BP,AAAO,MAAMiF,wBAGZ,GAAG,WAAUnB,GAAV,EAAejG,WAAf,EAA4B;QACxB,CAAC4E,QAAD,EAAWyC,eAAX,IAA8B,MAAMzD,QAAQ,CAACqC,GAAG,CAAC7B,IAAL,EAAWpE,WAAX,CAAlD;QACM,CAAC+E,SAAD,EAAYuC,gBAAZ,IAAgC,MAAM1D,QAAQ,CAClDqC,GAAG,CAAC5B,KAD8C,EAElDgD,eAFkD,CAApD;QAIME,sBAAsB,GAAG5B,uBAAuB,CAAC6B,GAAxB,CAA4BvB,GAAG,CAACwB,QAAhC,CAA/B;EACAC,MAAM,CACJH,sBADI,EAEH,gCAA+BtB,GAAG,CAACwB,QAAS,8BAFzC,CAAN;SAIOnF,WAAK,CAACiF,sBAAsB,CAAE3C,QAAF,EAAYG,SAAZ,CAAvB,EAA+CuC,gBAA/C,CAAZ;CAdK;;;;AAqBP,AAAO,MAAMK,eAAiD,GAAG,WAC/D1B,GAD+D,EAE/DjG,WAF+D,EAG/D;QACM4H,eAAe,GAAGzE,cAAc,CACL8C,GAAG,CAAChD,IADC,EAEpC,EAFoC,CAAtC;QAIM4E,WAAW,GAAGD,eAAe,CAACvF,QAAhB,CAAyBxB,cAAzB,CAClBb,WAAW,CAACjB,KAAZ,CAAkBwH,MADA,EAElB,EAFkB,EAGlBvG,WAHkB,CAApB;QAMM0D,uBAAuB,GAAG0C,yBAAyB,CAACyB,WAAD,CAAzD;;MAEIlI,aAAa,CAAC+D,uBAAuB,CAAC,CAAD,CAAxB,CAAjB,EAA+C;UACvC,CAACoE,cAAD,EAAiBC,iBAAjB,IAAsC,OAGfrE,uBAAuB,CAAC,CAAD,CAAvB,CAA2B3E,KAAtD,CAA6DG,UAA7D,CACE,UADF,CAHiD,CAMjDmD,QANiD,CAMxCxB,cANwC,CAOjD6C,uBAAuB,CAAC,CAAD,CAAvB,CAA2B3E,KAPsB,EAQjD,EARiD,EASjD2E,uBAAuB,CAAC,CAAD,CAT0B,CAAnD;WAWOpB,WAAK,CACV5D,SADU,EAEV6C,gBAAgB,CAAC,EACf,GAAGwG,iBAAiB,CAAChJ,KADN;MAEfiJ,MAAM,EAAwBF,cAAtB,CAAsC/I;KAFhC,CAFN,CAAZ;;;SASKuD,WAAK,CAAC5D,SAAD,EAAYgF,uBAAuB,CAAC,CAAD,CAAnC,CAAZ;CArCK;AAwCP,AAAO,MAAMuE,sBAAsB,GAAG/B,iBAAiB,CACrD,WAAUD,GAAV,EAAejG,WAAf,EAA4B;MACtBmC,eAAe,GAAGnC,WAAtB;;OACK,MAAM2D,SAAX,IAAwBsC,GAAG,CAAChD,IAA5B,EAAkC;OAC7Bd,eAAH,IAAsB,MAAMyB,QAAQ,CAACD,SAAD,EAAYxB,eAAZ,CAApC;;;SAGKG,WAAK,CAAC5D,SAAD,EAAYyD,eAAZ,CAAZ;CAPmD,CAAhD;AAWP,AAAO,MAAM+F,4BAGZ,GAAG,WAAUjC,GAAV,EAAejG,WAAf,EAA4B;MAC1BiG,GAAG,CAAC7B,IAAJ,CAAS7F,IAAT,KAAkB,kBAAtB,EAA0C;UAClC,CAACmI,UAAD,EAAa7B,oBAAb,IAAqC,MAAMjB,QAAQ,CACvDqC,GAAG,CAAC7B,IAAJ,CAASwC,MAD8C,EAEvD5G,WAFuD,CAAzD;UAIM,CAAC+E,SAAD,EAAYC,qBAAZ,IAAqC,MAAMpB,QAAQ,CACvDqC,GAAG,CAAC5B,KADmD,EAEvDQ,oBAFuD,CAAzD;IAI2B6B,UAA3B,CAAuCxH,UAAvC,CACgC+G,GAAG,CAAC7B,IAAJ,CAAS0C,QAAvC,CAAiDlF,IADnD,IAEImD,SAFJ;WAGOzC,WAAK,CAACyC,SAAD,EAAYC,qBAAZ,CAAZ;GAZF,MAaO;UACC,CAACD,SAAD,EAAYC,qBAAZ,IAAqC,MAAMpB,QAAQ,CACvDqC,GAAG,CAAC5B,KADmD,EAEvDrE,WAFuD,CAAzD;WAIOsC,WAAK,CACVyC,SADU,EAEVpD,kBAAkB,CAChBqD,qBADgB,EAEciB,GAAG,CAAC7B,IAAlC,CAAwCxC,IAFxB,EAGhBmD,SAHgB,CAFR,CAAZ;;CAtBG;AAiCP,AAAO,MAAMoD,uBAAuB,GAAGjC,iBAAiB,CAEtD,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;MAC9BoI,WAAM,CAACzE,SAAS,CAAC0E,QAAX,CAAV,EAAgC;WACvB/F,WAAK,CAAC9C,WAAW,CAACd,SAAD,CAAZ,EAAyBsB,WAAzB,CAAZ;;;QAEI,CAACmH,OAAD,EAAUmB,mBAAV,IAAiC,MAAM1E,QAAQ,CACnDD,SAAS,CAAC0E,QADyC,EAEnDrI,WAFmD,CAArD;SAIOsC,WAAK,CAAC9C,WAAW,CAAC2H,OAAD,CAAZ,EAAuBmB,mBAAvB,CAAZ;CAVsD,CAAjD;AAaP,AAAO,MAAMC,sBAGZ,GAAG,WAAUC,IAAV,EAAgBxI,WAAhB,EAA6B;SACxBsC,WAAK,CAACtC,WAAW,CAACjB,KAAZ,CAAkB2C,SAAnB,EAA8B1B,WAA9B,CAAZ;CAJK;AAOP,AAAO,MAAMyI,wBAGZ,GAAG,WAAUxC,GAAV,EAAejG,WAAf,EAA4B;MAC1B0I,GAAG,GAAG,EAAV;MACIvG,eAAe,GAAGnC,WAAtB;;OACK,MAAM8G,QAAX,IAAuBb,GAAG,CAAC/G,UAA3B,EAAuC;QACjCyJ,aAAJ;;QACI7B,QAAQ,CAACvI,IAAT,KAAkB,UAAtB,EAAkC;UAC5BuI,QAAQ,CAAC8B,SAAb,EAAwB;SACrBD,aAAD,EAAgBxG,eAAhB,IAAmC,MAAMyB,QAAQ,CAC/CkD,QAAQ,CAAC+B,GADsC,EAE/C1G,eAF+C,CAAjD;OADF,MAKO;SACJwG,aAAD,EAAgBxG,eAAhB,IAAmC,MAAMyB,QAAQ,CACvBkD,QAAQ,CAAC/H,KADc,EAE/CoD,eAF+C,CAAjD;;;;IAOJuG,GAAG,GAAG,EACJ,GAAGA,GADC;OAEuD5B,QAA5B,CAAsC+B,GAApE,CACEjH,IADH,GACU+G;KAHZ;;;SAOKrG,WAAK,CAACR,QAAQ,CAAC4G,GAAD,CAAT,EAAgBvG,eAAhB,CAAZ;CA7BK;AAgCP,AAAO,MAAM2G,0BAGZ,GAAG,WAAU7C,GAAV,EAAejG,WAAf,EAA4B;QACxB+I,YAAY,GAAG5F,cAAc,CAAC8C,GAAG,CAAChD,IAAJ,CAASA,IAAV,EAAgBgD,GAAG,CAAC5C,MAApB,CAAnC;SAEOf,WAAK,CACVyG,YADU,EAEV9C,GAAG,CAACjH,EAAJ,GACI2C,kBAAkB,CAChB3B,WADgB,EAEciG,GAAG,CAACjH,EAAlC,CAAsC4C,IAFtB,EAGhBmH,YAHgB,CADtB,GAMI/I,WARM,CAAZ;CANK;AAkBP,AAAO,MAAMgJ,2BAA2B,GAAG9C,iBAAiB,CAE1D,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;QAC5BU,MAAM,GAAG,MAAMkD,QAAQ,CAACD,SAAS,CAACT,UAAX,EAAuBlD,WAAvB,CAA7B;SACOsC,WAAK,CAAC5D,SAAD,EAAYgC,MAAM,CAAC,CAAD,CAAlB,CAAZ;CAJ0D,CAArD;AAOP,AAAO,MAAMuI,2BAA2B,GAAG/C,iBAAiB,CAE1D,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;MAC9BmC,eAAe,GAAGnC,WAAtB;;OACK,MAAMkJ,WAAX,IAA0BvF,SAAS,CAACwF,YAApC,EAAkD;QAC5CD,WAAW,CAACE,IAAhB,EAAsB;YACdC,UAAU,GAAG,MAAMzF,QAAQ,CAACsF,WAAW,CAACE,IAAb,EAAmBjH,eAAnB,CAAjC;MACAA,eAAe,GAAGR,kBAAkB,CAClC0H,UAAU,CAAC,CAAD,CADwB,EAEJH,WAAW,CAAClK,EAA1C,CAA8C4C,IAFZ,EAGlCyH,UAAU,CAAC,CAAD,CAHwB,CAApC;KAFF,MAOO;MACLlH,eAAe,GAAGR,kBAAkB,CAClCQ,eADkC,EAEJ+G,WAAW,CAAClK,EAA1C,CAA8C4C,IAFZ,EAGlClD,SAHkC,CAApC;;;;SAOG4D,WAAK,CAAC5D,SAAD,EAAYyD,eAAZ,CAAZ;CApB0D,CAArD;AAuBP,AAAO,MAAMmH,2BAA2B,GAAGpD,iBAAiB,CAE1D,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;SAC3BsC,WAAK,CACV5D,SADU,EAEViD,kBAAkB,CAChB3B,WADgB,EAEc2D,SAAS,CAAC3E,EAAxC,CAA4C4C,IAF5B,EAGhBuB,cAAc,CAACQ,SAAS,CAACV,IAAV,CAAeA,IAAhB,EAAsBU,SAAS,CAACN,MAAhC,CAHE,CAFR,CAAZ;CAH0D,CAArD;AAaP,AAAO,MAAMkG,mBAAmB,GAAGrD,iBAAiB,CAClD,WAAUvC,SAAV,EAAqBJ,WAArB,EAAkC;QAC1B,CAACiG,QAAD,EAAWC,oBAAX,IAAmC,MAAM7F,QAAQ,CACrDD,SAAS,CAAC+F,IAD2C,EAErDnG,WAFqD,CAAvD;QAIMoG,iBAAiB,GAAG3F,eAAe,CAACwF,QAAD,CAAzC;;MAEIG,iBAAiB,CAAC5K,KAAlB,KAA4B,IAAhC,EAAsC;UAC9B,GAAG6K,qBAAH,IAA4B,MAAMhG,QAAQ,CAC9CD,SAAS,CAACkG,UADoC,EAE9CJ,oBAF8C,CAAhD;WAIOnH,WAAK,CAAC5D,SAAD,EAAYkL,qBAAZ,CAAZ;GALF,MAMO,IAAID,iBAAiB,CAAC5K,KAAlB,KAA4B,KAAhC,EAAuC;QACxC4E,SAAS,CAACmG,SAAd,EAAyB;YACjB,GAAGF,qBAAH,IAA4B,MAAMhG,QAAQ,CAC9CD,SAAS,CAACmG,SADoC,EAE9CL,oBAF8C,CAAhD;aAIOnH,WAAK,CAAC5D,SAAD,EAAYkL,qBAAZ,CAAZ;;;WAGKtH,WAAK,CAAC5D,SAAD,EAAY+K,oBAAZ,CAAZ;;;SAGKxF,mBAAa,EAApB;CA1BgD,CAA7C;AA8BP,AAAO,MAAM8F,sBAAsB,GAAG7D,iBAAiB,CACrD,WAAUvB,CAAV,EAAa3E,WAAb,EAA0B;SACjBsC,WAAK,CAAC5D,SAAD,EAAYsB,WAAZ,CAAZ;CAFmD,CAAhD;AAMP,AAAO,MAAMgK,qBAGZ,GAAG,WAAU9G,UAAV,EAAsBlD,WAAtB,EAAmC;MACjC,CAACiC,UAAD,EAAa0E,cAAb,IAA+B,MAAM/C,QAAQ,CAC/CV,UAAU,CAAC8D,MADoC,EAE/ChH,WAF+C,CAAjD;MAKImC,eAAe,GAAGwE,cAAtB;MACIzE,SAAgB,GAAG,EAAvB;;OAEK,MAAM+E,MAAX,IAAqB/D,UAAU,CAACgE,SAAhC,EAA2C;UACnC,CAACC,OAAD,EAAUR,cAAV,IAA4B,MAAM/C,QAAQ,CAACqD,MAAD,EAASjH,WAAT,CAAhD;IACAkC,SAAS,GAAG,CAAC,GAAGA,SAAJ,EAAeiF,OAAf,CAAZ;IACAhF,eAAe,GAAGwE,cAAlB;;;SAGK,OAAO3E,8BAA8B,CACdC,UADc,EAE1CC,SAF0C,EAG1CC,eAH0C,CAA5C;CAlBK;AAyBP,AAAO,MAAM8H,yBAGZ,GAAG,WAAU/G,UAAV,EAAsBlD,WAAtB,EAAmC;QAC/BkK,uBAAuB,GAAGrE,wBAAwB,CAAC2B,GAAzB,CAC9BtE,UAAU,CAACuE,QADmB,CAAhC;EAGAC,MAAM,CACJwC,uBADI,EAEH,wBAAuBhH,UAAU,CAACuE,QAAS,+BAFxC,CAAN;SAIO,OAAOyC,uBAAuB,CACnChH,UAAU,CAACkB,IADwB,EAEnClB,UAAU,CAACmB,KAFwB,EAGnCrE,WAHmC,CAArC;CAXK;AAkBP,AAAO,MAAMmK,oBAAoB,GAAGjE,iBAAiB,CACnD,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;QAC1BoK,wBAAwB,GAAGxG,QAAQ,CAACD,SAAS,CAAC0G,KAAX,EAAkBrK,WAAlB,CAAzC;;MACIL,aAAa,CAACyK,wBAAwB,CAAC,CAAD,CAAzB,CAAjB,EAAgD;UACxCE,0BAA0B,GAAG3I,kBAAkB,CACnDyI,wBAAwB,CAAC,CAAD,CAD2B,EAGlBzG,SAAS,CAAC4G,OAAzC,CAAkDC,KADpD,CAEE5I,IAJiD,EAKnDwI,wBAAwB,CAAC,CAAD,CAAxB,CAA4BrL,KALuB,CAArD;WAOO6E,QAAQ,CACkBD,SAAS,CAAC4G,OAAzC,CAAkDtH,IADrC,EAEbqH,0BAFa,CAAf;;;SAMKF,wBAAP;CAjBiD,CAA9C;AAqBP,AAAO,MAAMK,sBAAsB,GAAGvE,iBAAiB,CACrD,WAAUvC,SAAV,EAAqB3D,WAArB,EAAkC;QAC1B,CAACmH,OAAD,EAAUmB,mBAAV,IAAiC,MAAM1E,QAAQ,CACnDD,SAAS,CAAC0E,QADyC,EAEnDrI,WAFmD,CAArD;SAIOsC,WAAK,CAAC5C,WAAW,CAACyH,OAAD,CAAZ,EAAuBmB,mBAAvB,CAAZ;CANmD,CAAhD;AAUP,AAAO,MAAMoC,wBAAwB,GAAGxE,iBAAiB,CAEvD,WAAUyE,UAAV,EAAsB3K,WAAtB,EAAmC;SAC5BsC,WAAK,CAAC5D,SAAD,EAAYsB,WAAZ,CAAZ;CAHuD,CAAlD;AAMP,AAAO,MAAM4K,wBAGZ,GAAG,WAAU1H,UAAV,EAAsBlD,WAAtB,EAAmC;MACjCkD,UAAU,CAACmF,QAAX,CAAoB9J,IAApB,KAA6B,YAAjC,EAA+C;UACvC,CAAC4I,OAAD,EAAUmB,mBAAV,IAAiC,MAAM1E,QAAQ,CACnDV,UAAU,CAACmF,QADwC,EAEnDrI,WAFmD,CAArD;QAKI6K,kBAAJ;;QACI3H,UAAU,CAACuE,QAAX,KAAwB,IAA5B,EAAkC;MAChCoD,kBAAkB,GAAG/L,QAAQ,CACcqI,OAAtB,CAA+BpI,KAAlD,GAA2D,CADhC,CAA7B;KADF,MAIO;aACEkF,mBAAa,EAApB;;;UAGI6G,sBAAsB,GAAGnJ,kBAAkB,CAC/C2G,mBAD+C,EAE/CpF,UAAU,CAACmF,QAAX,CAAoBzG,IAF2B,EAG/CiJ,kBAH+C,CAAjD;WAMOvI,WAAK,CAACuI,kBAAD,EAAqBC,sBAArB,CAAZ;;;SAGK7G,mBAAa,EAApB;CA5BK;AA+BP,AAAO,MAAM8G,uBAGZ,GAAG,WAAU7H,UAAV,EAAsBlD,WAAtB,EAAmC;QAC/B,CAACmH,OAAD,EAAUmB,mBAAV,IAAiC,MAAM1E,QAAQ,CACnDV,UAAU,CAACmF,QADwC,EAEnDrI,WAFmD,CAArD;QAIMgL,qBAAqB,GAAGlF,sBAAsB,CAAC0B,GAAvB,CAA2BtE,UAAU,CAACuE,QAAtC,CAA9B;EACAC,MAAM,CACJsD,qBADI,EAEH,+BACC9H,UAAU,CAACuE,QACZ,8BAJG,CAAN;SAMOuD,qBAAqB,CAAE7D,OAAF,EAAWmB,mBAAX,CAA5B;CAfK;AAkBP,AAAO,MAAM2C,YAAY,GAAG,IAAIrF,GAAJ,CAAuC,CACjE,CAAC,SAAD,EAAYY,eAAZ,CADiE,EAEjE,CAAC,YAAD,EAAeH,kBAAf,CAFiE,EAGjE,CAAC,kBAAD,EAAqBI,wBAArB,CAHiE,EAIjE,CAAC,gBAAD,EAAmBM,sBAAnB,CAJiE,EAKjE,CAAC,kBAAD,EAAqBK,wBAArB,CALiE,EAMjE,CAAC,SAAD,EAAYO,eAAZ,CANiE,EAOjE,CAAC,sBAAD,EAAyBO,4BAAzB,CAPiE,EAQjE,CAAC,iBAAD,EAAoBC,uBAApB,CARiE,EASjE,CAAC,gBAAD,EAAmBI,sBAAnB,CATiE,EAUjE,CAAC,kBAAD,EAAqBE,wBAArB,CAViE,EAWjE,CAAC,oBAAD,EAAuBK,0BAAvB,CAXiE,EAYjE,CAAC,qBAAD,EAAwBE,2BAAxB,CAZiE,EAajE,CAAC,qBAAD,EAAwBC,2BAAxB,CAbiE,EAcjE,CAAC,qBAAD,EAAwBK,2BAAxB,CAdiE,EAejE,CAAC,aAAD,EAAgBC,mBAAhB,CAfiE,EAgBjE,CAAC,gBAAD,EAAmBQ,sBAAnB,CAhBiE,EAiBjE,CAAC,gBAAD,EAAmB9B,sBAAnB,CAjBiE,EAkBjE,CAAC,eAAD,EAAkB+B,qBAAlB,CAlBiE,EAmBjE,CAAC,mBAAD,EAAsBC,yBAAtB,CAnBiE,EAoBjE,CAAC,cAAD,EAAiBE,oBAAjB,CApBiE,EAqBjE,CAAC,gBAAD,EAAmBM,sBAAnB,CArBiE,EAsBjE,CAAC,kBAAD,EAAqBC,wBAArB,CAtBiE,EAuBjE,CAAC,kBAAD,EAAqBE,wBAArB,CAvBiE,EAwBjE,CAAC,iBAAD,EAAoBG,uBAApB,CAxBiE,CAAvC,CAArB;;AChgBA,MAAMG,kBAAN,SAAiCC,KAAjC,CAAuC;EAC5CC,WAAW,CAACC,GAAD,EAAoBpF,GAApB,EAAsC;UACzCoF,GAAG,CAACC,OAAV;;SACKC,KAAL,GAAaF,GAAG,CAACE,KAAjB;;;;AAIJ,AAAO,MAAMC,mBAAN,SAAkCN,kBAAlC,CAAqD;EAC1DE,WAAW,CAACK,QAAD,EAAsChJ,IAAtC,EAAoD;UACvDgJ,QAAN,EAAgBA,QAAQ,CAACxF,GAAzB;;SACKsF,KAAL,GAAaE,QAAQ,CAACF,KAAtB;;;;AAUJ,AAAO,SAAS3H,QAAT,CACLqC,GADK,EAELjG,WAFK,EAGoB;MACrB;UACI0L,QAAQ,GAAGT,YAAY,CAACzD,GAAb,CAAiBvB,GAAG,CAAC1H,IAArB,CAAjB;IACAmJ,MAAM,CAACgE,QAAD,EAAY,kCAAiCzF,GAAG,CAAC1H,IAAK,EAAtD,CAAN;UACM4H,UAAU,GAAGuF,QAAQ,CAAEzF,GAAF,EAAOjG,WAAW,IAAIuB,gBAAgB,CAAC,EAAD,CAAtC,CAA3B;WAGE6E,yBAAyB,CAACD,UAAD,CAD3B;GALF,CAQE,OAAOkF,GAAP,EAAY;QAEVA,GAAG,YAAYH,kBAAf,IACAG,GAAG,YAAYG,mBAFjB,EAGE;YACMH,GAAN;;;UAEI,IAAIH,kBAAJ,CAAuBG,GAAvB,EAA4BpF,GAA5B,CAAN;;;AAIJ,AAAO,SAAS0F,YAAT,CAAsBlJ,IAAtB,EAAoCzC,WAApC,EAAoE;MACrE;WACK4D,QAAQ,CAACpB,kBAAkB,CAACC,IAAD,CAAnB,EAA2BzC,WAA3B,CAAf;GADF,CAEE,OAAOqL,GAAP,EAAY;QACRA,GAAG,YAAYG,mBAAnB,EAAwC;YAChCH,GAAN;KADF,MAEO,IAAIA,GAAG,YAAYH,kBAAnB,EAAuC;YACtC,IAAIM,mBAAJ,CAAwBH,GAAxB,EAA6B5I,IAA7B,CAAN;;;UAEI4I,GAAN;;;AAIJ,AAAO,SAASO,wBAAT,CACLnJ,IADK,EAELzC,WAFK,EAGL;SACO4D,QAAQ,CAAClB,kBAAW,CAACD,IAAD,CAAZ,EAAoBzC,WAApB,CAAf;;AAGF,AAAO,SAASoG,yBAAT,CAELyF,GAFK,EAEG;MACJnI,uBAAuB,GAAGmI,GAAG,CAACC,IAAJ,EAA9B;;SAEE,CAACnM,aAAa,CAAC+D,uBAAuB,CAAC3E,KAAxB,CAA8B,CAA9B,CAAD,CAAd,IACA,CAACU,aAAa,CAACiE,uBAAuB,CAAC3E,KAAxB,CAA8B,CAA9B,CAAD,CADd,IAEA,CAAC2E,uBAAuB,CAACqI,IAH3B,EAIE;IACArI,uBAAuB,GAAGmI,GAAG,CAACC,IAAJ,CAASpI,uBAAuB,CAAC3E,KAAjC,CAA1B;;;SAGK2E,uBAAuB,CAAC3E,KAA/B;;;ACvFK,UAAUiN,MAAV,CACLC,KADK,EAELlM,KAFK,EAGLC,WAHK,EAIL;SACO,CAACQ,QAAQ,EAAT,EAAaR,WAAb,CAAP;;;ACLK,UAAUkM,KAAV,CACLnJ,KADK,EAELzC,IAFK,EAGLN,WAHK,EAIL;MACI,CAACM,IAAI,CAAC,CAAD,CAAL,IAAY1B,UAAU,CAAC0B,IAAI,CAAC,CAAD,CAAL,CAA1B,EAAqC;WAC5B,CAAClC,UAAD,EAAa4B,WAAb,CAAP;GADF,MAEO;WACE,CACL;MACEe,MAAM,EAAEoL,IAAI,CAACD,KAAL,CAA8B5L,IAAI,CAAC,CAAD,CAAJ,CAAQvB,KAAtC;KAFL,EAILiB,WAJK,CAAP;;;;ACVG,MAAMmM,MAAI,GAAG;EAClBjN,UAAU,EAAE;IACVgN,KAAK,EAAE;MACLrL,cAAc,EAAEqL;;;CAHf;;ACOA,MAAME,MAAM,GAAGxJ,UAAU,CAAC,WAC/BG,KAD+B,EAE/BzC,IAF+B,EAG/BN,WAH+B,EAI/B;QACMqM,MAAM,GAA4C/L,IAAI,CAAC,CAAD,CAA1B,CAA+BvB,KAAjE;QACMuN,YAAY,GAAG9J,kBAAkB,CAAC6J,MAAD,CAAvC;QACMjJ,UAAU,GAAGkJ,YAAY,CAACrJ,IAAhC;MAEIS,uBAAuB,GAAGpB,WAAK,CAAC5D,SAAD,EAAYsB,WAAZ,CAAnC;;OACK,MAAM2D,SAAX,IAAwBP,UAAU,CAACmJ,KAAX,CAAiB,CAAjB,EAAoBnJ,UAAU,CAAC7D,MAAX,GAAoB,CAAxC,CAAxB,EAAoE;IAClEmE,uBAAuB,GAAG,MAAME,QAAQ,CACtCD,SADsC,EAEtCD,uBAAuB,CAAC,CAAD,CAFe,CAAxC;;;QAMI8I,aAAa,GAAGpJ,UAAU,CAACA,UAAU,CAAC7D,MAAX,GAAoB,CAArB,CAAhC;;MAEIiN,aAAa,CAACjO,IAAd,KAAuB,qBAA3B,EAAkD;WACzCqF,QAAQ,CAAC4I,aAAa,CAACtJ,UAAf,EAA2BQ,uBAAuB,CAAC,CAAD,CAAlD,CAAf;;;SAGKE,QAAQ,CAAC4I,aAAD,EAAgB9I,uBAAuB,CAAC,CAAD,CAAvC,CAAf;CAvB8B,CAAzB;;ACLA,MAAM+I,iBAAiB,GAAG7J,UAAU,CAAC,WAC1CG,KAD0C,EAE1CzC,IAF0C,EAG1CN,WAH0C,EAI1C;SACO,CAACM,IAAI,CAAC,CAAD,CAAL,EAAUN,WAAV,CAAP;CALyC,CAApC;;ACAA,MAAM0M,iBAAiB,GAAG9J,UAAU,CAAC,WAC1CG,KAD0C,EAE1CzC,IAF0C,EAG1CN,WAH0C,EAI1C;SACOsC,WAAK,CAAChC,IAAI,CAAC,CAAD,CAAL,EAAUN,WAAV,CAAZ;CALyC,CAApC;;ACIA,MAAM2M,eAAe,GAAG;EAC7BzN,UAAU,EAAE;UACViN,MADU;IAEVS,QAAQ,EAAE9J,mBAFA;IAGV+J,IAAI,EAAET,MAHI;IAIVU,MAAM,EAAEhJ,iBAJE;IAKVzF,MAAM,EAAEoO,iBALE;IAMVM,OAAO,EAAE7I,oBANC;IAOV8I,MAAM,EAAEN;;CARL;;ACFA,MAAMO,sBAAsB,GAAGrK,UAAU,CAAC,WAC/C9C,IAD+C,EAE/CQ,IAF+C,EAG/CN,WAH+C,EAI/C;EAC2BF,IAA3B,CAAiCZ,UAAjC,CAA4CoM,OAA5C,GAAsDhL,IAAI,CAAC,CAAD,CAA1D;SACOgC,WAAK,CAAC5D,SAAD,EAAYsB,WAAZ,CAAZ;CAN8C,CAAzC;;AAUPiN,sBAAsB,CAAC/N,UAAvB,CAAkCqD,SAAlC,CAA4CrD,UAA5C,CAAuD2E,QAAvD,GAAkEjB,UAAU,CAC1E,WAAU9C,IAAV,EAAqBC,KAArB,EAAmCC,WAAnC,EAAmE;SAC1DsC,WAAK,CACiBxC,IAA3B,CAAiCZ,UAAjC,CAA4CoM,OADlC,EAEVtL,WAFU,CAAZ;CAFwE,CAA5E;;ACFO,MAAMkN,EAAE,GAAG;EAChBhO,UAAU,EAAE;IACViO,aAAa,EAAE;MACbC,UAAU,EAAE,EADC;MAEb/K,QAAQ,EAAE;QACRxB,cAAc,EAAE,WACdkC,KADc,EAEdzC,IAFc,EAGdN,WAHc,EAId;iBACO,CAACM,IAAI,CAAC,CAAD,CAAL,EAAUN,WAAV,CAAP;;;KATI;IAaVqN,YAAY,EAAE;MACZD,UAAU,EAAE,EADA;MAEZ/K,QAAQ,EAAE;QACRxB,cAAc,EAAE,WACdkC,KADc,EAEdzC,IAFc,EAGdN,WAHc,EAId;gBACMsN,eAAe,GAAG/L,gBAAgB,CACtCgM,OAAO,CAACvN,WAAW,CAACjB,KAAb,EAAoByO,KAAK,IAAI;YAClCA,KAAK,CAACjH,MAAN,GAAezE,QAAQ,CAAC,EACtB,GAAG6K,eAAe,CAACzN,UADG;iBAEGoB,IAAI,CAAC,CAAD,CAA1B,CAA+BpB;aAFb,CAAvB;WADK,CAD+B,CAAxC;;cAQI;mBACKyM,YAAY,CACwBrL,IAAI,CAAC,CAAD,CAA1B,CAA+BvB,KADjC,EAEjBuO,eAFiB,CAAnB;WADF,CAKE,OAAOjC,GAAP,EAAY;gBACRA,GAAG,YAAYoC,WAAnB,EAAgC;oBACxB,CACJC,WADI,EAEJC,qBAFI,IAGF,OAAO3L,8BAA8B,CACvCiL,sBADuC,EAEvC,CAACzM,QAAQ,CAAC6K,GAAG,CAACE,KAAL,CAAT,CAFuC,EAGvC+B,eAHuC,CAHzC;qBAQOhL,WAAK,CAAC5C,WAAW,CAACgO,WAAD,CAAZ,EAA2BC,qBAA3B,CAAZ;;;kBAEItC,GAAN;;;;;;CA/CL;;ACZA,MAAMuC,kBAAkB,GAAG,IAAIhI,GAAJ,CAAQ,CAAC,CAAC,IAAD,EAAOsH,EAAP,CAAD,CAAR,CAA3B;;ACIA,MAAMW,eAAe,GAAG;EAC7BT,UAAU,EAAE,EADiB;EAE7B/K,QAAQ,EAAE;IACRxB,cAAc,EAAE,WACdkC,KADc,EAEdzC,IAFc,EAGdwN,UAHc,EAId;aACO,CACLF,kBAAkB,CAACpG,GAAnB,CAC2ClH,IAAI,CAAC,CAAD,CAA1B,CAA+BvB,KADpD,CADK,EAIL+O,UAJK,CAAP;;;CARC;;MCDMC,2BAA2B,GAAGxM,gBAAgB,CAAC;EAC1DgF,MAAM,EAAE;IACNrH,UAAU,EAAE,EACV,GAAGyN,eAAe,CAACzN,UADT;MAEV8M,MAAM,EAAE;QACNoB,UAAU,EAAE,EADN;QAEN/K,QAAQ,EAAE;UACRxB,cAAc,EAAEmL;;;;GAPkC;EAY1DnK,KAAK,EAAE;IACLmM,OAAO,EAAEH;;CAb8C,CAApD;;;;;;;;;;"}
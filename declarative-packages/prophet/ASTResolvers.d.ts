import { TESString } from "./string/String";
import { Any, FunctionBinding, ControlFlowResult, TESNumber } from "./types";
import { TExecutionContext } from "./execution-context/ExecutionContext";
import { ESTree } from "cherow";
export declare type ASTResolver<TAST extends ESTree.Node, T extends Any> = (ast: TAST, prevContext: TExecutionContext) => Iterator<[T | ControlFlowResult, TExecutionContext]>;
export declare const noExecutionContextResolver: <TAST extends any, T extends any>(fn: (ast: TAST, execContext: any) => T) => (ast: TAST, execContext: any) => IterableIterator<any>;
export declare const statementResolver: <TStatement extends any>(fn: (ast: TStatement, execContext: any) => IterableIterator<[any, any]>) => (ast: TStatement, execContext: any) => IterableIterator<any>;
export declare const IdentifierResolver: ASTResolver<ESTree.Identifier, Any>;
export declare const LiteralResolver: ASTResolver<ESTree.Literal, Any>;
export declare const MemberExpressionResolver: ASTResolver<ESTree.MemberExpression, Any>;
export declare const CallExpressionResolver: ASTResolver<ESTree.CallExpression, Any>;
export declare const BinaryExpressionResolver: ASTResolver<ESTree.BinaryExpression, any | TESString>;
export declare const ProgramResolver: ASTResolver<ESTree.Program, Any>;
export declare const BlockStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const AssignmentExpressionResolver: ASTResolver<ESTree.AssignmentExpression, Any>;
export declare const ReturnStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const ThisExpressionResolver: ASTResolver<ESTree.ThisExpression, Any>;
export declare const ObjectExpressionResolver: ASTResolver<ESTree.ObjectExpression, Any>;
export declare const FunctionExpressionResolver: ASTResolver<ESTree.FunctionExpression, FunctionBinding>;
export declare const ExpressionStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const VariableDeclarationResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const FunctionDeclarationResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const IfStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const EmptyStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const NewExpressionResolver: ASTResolver<ESTree.NewExpression, Any>;
export declare const LogicalExpressionResolver: ASTResolver<ESTree.LogicalExpression, Any>;
export declare const TryStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const ThrowStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const DoWhileStatementResolver: (ast: any, execContext: any) => IterableIterator<any>;
export declare const UpdateExpressionResolver: ASTResolver<ESTree.UpdateExpression, TESNumber>;
export declare const UnaryExpressionResolver: ASTResolver<ESTree.UnaryExpression, Any>;
export declare const ASTResolvers: Map<string, ASTResolver<any, any>>;
//# sourceMappingURL=ASTResolvers.d.ts.map